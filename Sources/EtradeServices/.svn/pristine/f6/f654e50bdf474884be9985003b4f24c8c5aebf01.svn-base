// --------------------------------------------------------------------------------------------------------------------
// <copyright file="METradeServicesWebServices.asmx.cs" company="OTS">
//   2013
// </copyright>
// <summary>
//   Summary description for ETradeServicesWebServices
// </summary>
// --------------------------------------------------------------------------------------------------------------------
using System.Diagnostics;
using System.Linq;
using System.Web.Configuration;
using System.Xml.Linq;
using ETradeGWServices;
using ETradeHistory.Entities;
using ETradeHistory.Services;
using ETradeOrders.Services;
using ETradeWebServices.Services;
using ETradeWebServices.Utils;

namespace MEtradeWebServices
{
    using System;
    using System.Collections.Generic;
    using System.Web;
    using System.Web.Caching;
    using System.Web.Script.Serialization;
    using System.Web.Script.Services;
    using System.Web.Services;
    using ETradeCommon;
    using ETradeCommon.Enums;
    using ETradeFinance.Entities;
    using ETradeCore.Entities;
    using ETradeOrders.Entities;
    using AMServices;

    using CashAdvance = ETradeCore.Entities.CashAdvance;
    using SubCustAccount = AccountManager.Entities.SubCustAccount;
    using AccountManager.Entities;

    /// <summary>
    /// Summary description for ETradeServicesWebServices
    /// </summary>
    [WebService(Namespace = "http://tempuri.org/")]
    [WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)]
    [System.ComponentModel.ToolboxItem(false)]
    // To allow this Web Service to be called from script, using ASP.NET AJAX, uncomment the following line. 
    [ScriptService]
    public class MEtradeWebService : System.Web.Services.WebService
    {
        private static readonly JavaScriptSerializer Serializer = new JavaScriptSerializer();

        /// <summary>
        /// Exception policy
        /// </summary>
        public const string WEB_SERVICE_POLICY = "WebServiceExceptionPolicy";

        /// <summary>
        /// </summary>
        private static readonly AccountManagerServices AccountManagerServices = new AccountManagerServices();

        private static readonly METradeWebServices.Services.ETradeServices ETradeServices = new METradeWebServices.Services.ETradeServices();
        private static readonly ValidateServices ValidateServices = new ValidateServices();
        private static readonly ConditionOrderService ConditionOrderService = new ConditionOrderService();
        private static readonly ConditionOrderDetailService ConditionOrderDetailService = new ConditionOrderDetailService();
        #region account manager

        /// <summary>
        /// Logins the specified username.
        /// </summary>
        /// <param name="username">The username.</param>
        /// <param name="password">The password.</param>
        /// <returns>
        /// 	<para>A <see cref="ResultObject{T}">ResultObject&lt;MainCustAccount&gt;</see> object contains returned code, returned message and
        /// main customer account information.</para>
        /// 	<para>RET_CODE=SUCCESS: Log in successfully.</para>
        /// 	<para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Logon for investor, authType = 0: pin/pass, 1: RSA, 2: TODOS, 3: ENTRUST return ResultObject<MainCustAccount>",
            EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string Login(string username, string password)
        {
            int result;
            try
            {
                result =
                int.TryParse(
                    AccountManagerServices.AuthenticateCustLogon(username, password).ToString(),
                    out result)
                    ? result
                    : 0;
            }
            catch (Exception e)
            {

                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<MainCustAccount>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                            });
            }

            if (result != (int)CommonEnums.RET_CODE.SUCCESS)
            {
                return
                    Serializer.Serialize(
                        new ResultObject<MainCustAccount>
                        {
                            Result = null,
                            RetCode = (CommonEnums.RET_CODE)result,
                            ErrorMessage = ((CommonEnums.RET_CODE)result).ToString()
                        });
            }

            string retVal = AccountManagerServices.GetCustomerNoSession(username);

            var mainCustAccount = Serializer.Deserialize<ResultObject<MainCustAccount>>(
                retVal);

            //var resultObject = new ResultObject<AccountManager.Entities.MainCustAccount> { RetCode = (CommonEnums.RET_CODE)result, Result = mainCustAccount.Result };

            Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] = username;
            Session[CommonEnums.SESSION_KEY.PASSWORD.ToString()] = mainCustAccount.Result.Password;
            Session[CommonEnums.SESSION_KEY.PIN.ToString()] = mainCustAccount.Result.Pin;
            Session[CommonEnums.SESSION_KEY.CUSTOMER_TYPE.ToString()] = mainCustAccount.Result.CustomerType;
            string apiKey = Guid.NewGuid().ToString();
            Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] = apiKey;
            /*Session[CommonEnums.SESSION_KEY.LIST_SUB_ACCOUNTS.ToString()] =
                mainCustAccount.Result.SubCustAccountCollection;*/

            var subCustAccountIdList = new List<string>();
            var subCustAccountCollection = mainCustAccount.Result.SubCustAccountCollection;

            foreach (SubCustAccount subCustAccount in subCustAccountCollection)
            {
                Session[subCustAccount.SubCustAccountId + CommonEnums.SESSION_KEY.TRADING_ACCOUNT] = subCustAccount;
                subCustAccountIdList.Add(subCustAccount.SubCustAccountId);
            }
            Session[CommonEnums.SESSION_KEY.LIST_SUB_ACCOUNTS.ToString()] = subCustAccountIdList;

            // Put sessionId into cache to compare user session later
            string cacheKey = username;
            var cacheTimeout = new TimeSpan(0, 0, HttpContext.Current.Session.Timeout, 0, 0);
            if (HttpContext.Current.Cache[cacheKey] != null)
            {
                HttpContext.Current.Cache.Remove(cacheKey);
            }

            HttpContext.Current.Cache.Insert(
                cacheKey, Session.SessionID, null, Cache.NoAbsoluteExpiration, cacheTimeout);

            var resultVal = new Entities.LoginResult();
            resultVal.ApiKey = apiKey;
            resultVal.MainCustAccountJson = retVal;
            return Serializer.Serialize(resultVal);
        }
        /// <summary>
        /// Logouts the specified session id.
        /// </summary>
        /// <returns>
        /// <para>A <see cref="ResultObject{T}">ResultObject&lt;CommonEnums.RET_CODE&gt;</see> object contains returned code, returned message and 
        /// result of logging out.</para>
        /// <para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// <para>RET_CODE=SUCCESS: Log out successfully.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Logout for investor, return ResultObject<CommonEnums.RET_CODE>", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string Logout(string apiKey)
        {
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<CommonEnums.RET_CODE>
                            {
                                Result = CommonEnums.RET_CODE.NOT_LOGIN,
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null|| Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey)!=0)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<CommonEnums.RET_CODE>
                            {
                                Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                                RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                                ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                            });
                }

                var resultObject = new ResultObject<CommonEnums.RET_CODE>
                {
                    RetCode = CommonEnums.RET_CODE.SUCCESS,
                    Result = CommonEnums.RET_CODE.SUCCESS,
                    ErrorMessage =
                        CommonEnums.RET_CODE.SUCCESS.ToString()
                };

                Session.Abandon();
                string accountNo = Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()].ToString();
                AccountManagerServices.CustomerLogout(accountNo);
                if (HttpContext.Current.Cache[accountNo] != null)
                {
                    HttpContext.Current.Cache.Remove(accountNo);
                }
                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<CommonEnums.RET_CODE>
                            {
                                Result = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                            });
            }
        }
        ///<summary>
        /// Get list of online customer
        ///</summary>
        ///<returns></returns>
        [WebMethod(Description = "Get list of online customers")]
        public string GetListOnlineCustomers(string apiKey)
        {
            if (string.IsNullOrEmpty(apiKey) || Session == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
            {
                return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                        });
            }    
            var customerList = new List<string>();
            var resultObject = new ResultObject<List<string>> { RetCode = CommonEnums.RET_CODE.SUCCESS };
            try
            {
                if ((HttpContext.Current != null) && (HttpContext.Current.Cache != null))
                {
                    var enumerator = HttpContext.Current.Cache.GetEnumerator();
                    while (enumerator.MoveNext())
                    {
                        var username = (string)enumerator.Key;
                        if (username.Length == 10)
                        {
                            customerList.Add((string)enumerator.Key);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
            }
            resultObject.Result = customerList;
            return Serializer.Serialize(resultObject);
        }
        /// <summary>
        /// Gets the account information.
        /// </summary>
        /// <param name="accountId">The account id.</param>
        /// <returns>
        /// <para>A <see cref="ResultObject{T}">ResultObject&lt;MainCustAccount&gt;</see> object contains returned code, returned message and 
        /// MainCustAccount object that contains main customer information.</para>
        /// <para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// <para>RET_CODE=SUCCESS: Get account successfully.</para>
        /// <para>RET_CODE=FAIL: Failed to get account.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Get account information, return ResultObject<MainCustAccount>", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string GetAccountInfo(string accountId,string apiKey)
        {
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<AccountManager.Entities.MainCustAccount>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<CommonEnums.RET_CODE>
                            {
                                Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                                RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                                ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                            });
                }
                //Check multiple account by an customer
                if (IsMultiAccount(accountId, string.Empty))
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<MainCustAccount>
                        {
                            Result = null,
                            RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                            ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                        });
                }

                string returnVal = AccountManagerServices.GetCustomerNoSession(accountId);

                return returnVal;
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<AccountManager.Entities.MainCustAccount>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                            });
            }
        }
        /// <summary>
        /// Forgets the password.
        /// </summary>
        /// <param name="mainCustAccountId">The main cust account id.</param>
        /// <param name="identifyNumber">The identify number.</param>
        /// <param name="messagePhone">The message phone.</param>
        /// <returns></returns>
        [WebMethod(Description = "Get account information, return ResultObject<MainCustAccount>", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public int ForgetPassword(string mainCustAccountId, string identifyNumber, string messagePhone,string apiKey)
        {
            if (string.IsNullOrEmpty(apiKey) ||Session==null|| Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
            {
                    return (int)CommonEnums.RET_CODE.INVAILID_API_KEY;                        
            }
            try
            {
                string result = AccountManagerServices.ForgetPassword(mainCustAccountId, identifyNumber, messagePhone);
                var resultObject = Serializer.Deserialize<ResultObject<string>>(result);
                if (resultObject != null)
                {
                    return (int)resultObject.RetCode;
                }
                return (int)CommonEnums.RET_CODE.FAIL;
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return (int)CommonEnums.RET_CODE.FAIL;
            }
        }
        /// <summary>
        /// Request new pin.
        /// </summary>
        /// <param name="mainCustAccountId">Main customer account id.</param>
        /// <returns>
        /// <para>RET_CODE=INCORECT_INFORMATION: Wrong some information.</para>
        /// <para>RET_CODE=SUCCESS: Generate pin successfully.</para>
        ///  <para>RET_CODE=NO_EXIST_DATA: wrong main cust account id</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// <para>RET_CODE=FAIL: Action fail.</para>
        /// <para>RET_CODE=ERROR_SENT_MESSAGE: Send message fail.</para>
        /// </returns>
        [WebMethod(Description = "Send message to customer", EnableSession = true)]
        public int ForgetPin(string mainCustAccountId,string apiKey)
        {
            if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
            {
                return (int)CommonEnums.RET_CODE.NOT_LOGIN;
            }
            else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
            {
                return (int)CommonEnums.RET_CODE.INVAILID_API_KEY;
            }
            //Check multiple account by an customer
            if (IsMultiAccount(mainCustAccountId, string.Empty))
            {
                return (int)CommonEnums.RET_CODE.NOT_LOGIN;
            }
            string result = AccountManagerServices.ForgetPin(mainCustAccountId);
            var resultObject = Serializer.Deserialize<ResultObject<string>>(result);
            if (resultObject != null)
            {
                if (resultObject.RetCode == CommonEnums.RET_CODE.SUCCESS)
                {
                    Session[CommonEnums.SESSION_KEY.PIN.ToString()] = resultObject.Result; // Update pin to session                    
                }
                return (int)resultObject.RetCode;
            }
            return (int)CommonEnums.RET_CODE.FAIL;
        }
        /// <summary>
        /// Changes the password.
        /// </summary>
        /// <param name="mainCustAccId">The main customer account id.</param>
        /// <param name="oldPass">The old pass.</param>
        /// <param name="newPass">The new pass.</param>
        /// <returns>
        /// <para>A <see cref="ResultObject{T}">ResultObject</see> object includes returned code, returned message, 
        /// and <see cref="CommonEnums.RET_CODE"/> information that contains result of changing password.</para>
        /// <para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// <para>RET_CODE=SUCCESS: Changing password successfully.</para>
        /// <para>RET_CODE=FAILED: Fail to change password successfully.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Change password for investor", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string ChangePassword(string mainCustAccId, string oldPass, string newPass,string apiKey)
        {
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<int>
                            {
                                Result = (int)CommonEnums.RET_CODE.NOT_LOGIN,
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    Serializer.Serialize(
                           new ResultObject<int>
                           {
                               Result = (int)CommonEnums.RET_CODE.INVAILID_API_KEY,
                               RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                               ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                           });
                }
                //Check multiple account by an customer
                if (IsMultiAccount(mainCustAccId, string.Empty))
                {
                    return Serializer.Serialize(new ResultObject<int>
                    {
                        Result = (int)CommonEnums.RET_CODE.NOT_LOGIN,
                        RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                        ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                    });
                }

                int result = AccountManagerServices.ChangeCustPassword(mainCustAccId, oldPass, newPass);

                var resultObject = new ResultObject<int> { RetCode = (CommonEnums.RET_CODE)result, Result = result };

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<int>
                            {
                                Result = -1,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                            });
            }
        }
        /// <summary>
        /// Chang pin of an investor
        /// </summary>
        /// <param name="accountId">
        /// The account id.
        /// </param>
        /// <param name="oldPin">
        /// The old pin.
        /// </param>
        /// <param name="newPin">
        /// The new pin.
        /// </param>
        /// <returns>
        /// <para>A <see cref="ResultObject{T}">ResultObject</see> object includes returned code, returned message, 
        /// and <see cref="CommonEnums.RET_CODE"/> information that contains result of changing pin.</para>
        /// <para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// <para>RET_CODE=SUCCESS: Changing pin successfully.</para>
        /// <para>RET_CODE=FAILED: Fail to change pin successfully.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Change pin for investor", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string ChangePin(string accountId, string oldPin, string newPin,string apiKey)
        {
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<int>
                            {
                                Result = (int)CommonEnums.RET_CODE.NOT_LOGIN,
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    Serializer.Serialize(
                           new ResultObject<int>
                           {
                               Result = (int)CommonEnums.RET_CODE.INVAILID_API_KEY,
                               RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                               ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                           });
                }
                //Check multiple account by an customer
                if (IsMultiAccount(accountId, string.Empty))
                {
                    return Serializer.Serialize(new ResultObject<int>
                    {
                        Result = (int)CommonEnums.RET_CODE.NOT_LOGIN,
                        RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                        ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                    });
                }

                int result = AccountManagerServices.ChangeCustPin(accountId, oldPin, newPin);
                if (result == (int)CommonEnums.RET_CODE.SUCCESS)
                    Session[CommonEnums.SESSION_KEY.PIN.ToString()] = PasswordHandlerMd5.Encrypt(newPin);
                var resultObject = new ResultObject<int> { RetCode = (CommonEnums.RET_CODE)result, Result = result };

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<int>
                            {
                                Result = -1,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                            });
            }
        }
        /// <summary>
        /// Connect to LinkOPS
        /// </summary>
        /// <returns>
        /// ResultObject of bool to show result of connection. 
        /// </returns>
        [WebMethod(Description = "Connect to LinkOPS, return a ResultObject<bool>", EnableSession = false)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string Connect(string apiKey)
        {
            if (string.IsNullOrEmpty(apiKey) ||Session==null|| Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
            {
                Serializer.Serialize(
                       new ResultObject<int>
                       {
                           Result = (int)CommonEnums.RET_CODE.INVAILID_API_KEY,
                           RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                           ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                       });
            }    
            try
            {
                ResultObject<bool> resultObject = ETradeServices.Connect(AppConfig.LinkOPSAddress, AppConfig.LinkOPSPort);

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<bool>
                            {
                                Result = false,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR
                            });
            }
        }
        /// <summary>
        /// Disconnect from LinkOPS
        /// </summary>
        /// <returns>
        /// ResultObject of bool to show result of disconnection. 
        /// </returns>
        [WebMethod(Description = "Disconnect from LinkOPS, return a ResultObject<bool>", EnableSession = false)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string Disconnect(string apiKey)
        {
            if (string.IsNullOrEmpty(apiKey) || Session == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
            {
                Serializer.Serialize(
                       new ResultObject<int>
                       {
                           Result = (int)CommonEnums.RET_CODE.INVAILID_API_KEY,
                           RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                           ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                       });
            } 
            try
            {
                ResultObject<bool> resultObject = ETradeServices.Disconnect();

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<bool>
                            {
                                Result = false,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR
                            });
            }
        }
        /// <summary>
        /// Is connected to LinkOPS
        /// </summary>
        /// <returns>
        /// <para>A <see cref="ResultObject{T}">ResultObject&lt;bool&gt;</see> object contains returned code, returned message and 
        /// the result of checking connection.</para>
        /// <para>RET_CODE=SUCCESS: Checking successfully.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Is connected to LinkOPS, return a ResultObject<bool>", EnableSession = false)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string IsConnected(string apiKey)
        {
            if (string.IsNullOrEmpty(apiKey) || Session == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
            {
                Serializer.Serialize(
                       new ResultObject<int>
                       {
                           Result = (int)CommonEnums.RET_CODE.INVAILID_API_KEY,
                           RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                           ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                       });
            } 
            try
            {
                ResultObject<bool> resultObject = ETradeServices.IsConnected();

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<int>
                            {
                                Result = -1,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR
                            });
            }
        }

        #endregion account manager
        #region market
        /// <summary>
        /// Gets the state of the trading.
        /// </summary>
        /// <param name="marketId">The market id.</param>
        /// <returns>
        /// <para>A <see cref="ResultObject{T}">ResultObject&lt;PagingObject&lt;List&lt;char&gt;&gt;&gt;</see> object contains returned code, returned message and 
        /// trading state information. If GW not connect to LinkOPS yet, the trading status wil be 'W'</para>
        /// <para>RET_CODE=SUCCESS: Getting data successfully.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Get current trading status, return objectResult of market status")]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string GetTradingState(int marketId,string apiKey)
        {
            if (string.IsNullOrEmpty(apiKey) || Session == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null|| Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey)!=0)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<CommonEnums.RET_CODE>
                            {
                                Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                                RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                                ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                            });
                }

            try
            {
                var tradingState = ETradeServices.GetTradingState(marketId);
                var resultObject = new ResultObject<char>
                {
                    Result = tradingState,
                    RetCode = CommonEnums.RET_CODE.SUCCESS,
                };

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<char>
                            {
                                Result = (char)CommonEnums.MARKET_STATUS.UNVAILABLE,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                            });
            }
        }
        /// <summary>
        /// Gets all states of the trading.
        /// </summary>
        /// <returns>
        /// <para>A <see cref="ResultObject{T}">ResultObject&lt;char[]&gt;</see> object contains returned code, returned message and 
        /// trading state information of all markets. If GW not connect to LinkOPS yet, the trading status wil be 'W'.
        /// Please refer to the MARKET_STATUS in CommonEnums.cs.</para>
        /// <para>RET_CODE=SUCCESS: Get data successfully.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Get current trading status, return objectResult of market status")]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string GetAllTradingState(string apiKey)
        {
            if (string.IsNullOrEmpty(apiKey) || Session == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null|| Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey)!=0)
            {
                return
                Serializer.Serialize(
                    new ResultObject<CommonEnums.RET_CODE>
                    {
                        Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                        RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                        ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                    });
            }
            var tradingState = new[]
                                      {
                                          (char) CommonEnums.MARKET_STATUS.UNVAILABLE,
                                          (char) CommonEnums.MARKET_STATUS.UNVAILABLE,
                                          (char) CommonEnums.MARKET_STATUS.UNVAILABLE
                                      };
            try
            {
                tradingState = ETradeServices.GetAllTradingState();
                var resultObject = new ResultObject<char[]>
                {
                    Result = tradingState,
                    RetCode = CommonEnums.RET_CODE.SUCCESS,
                };

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<char[]>
                            {
                                Result = tradingState,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                            });
            }
        }
        /// <summary>
        /// Gets order session of all markets.
        /// </summary>
        /// <returns>
        /// <para>A <see cref="ResultObject{T}">ResultObject&lt;char[]&gt;</see> object contains returned code, returned message and 
        /// order session of all markets.</para>
        /// <para>RET_CODE=SUCCESS: Get data successfully.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Get current order session, return objectResult of order session")]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string GetAllOrderSession(string apiKey)
        {
            if (string.IsNullOrEmpty(apiKey) || Session == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
            {
                return
                Serializer.Serialize(
                    new ResultObject<CommonEnums.RET_CODE>
                    {
                        Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                        RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                        ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                    });
            }
            var orderSessions = new[]
                                      {
                                          (char) CommonEnums.ORDER_SESSION.SESSION0,
                                          (char) CommonEnums.ORDER_SESSION.SESSION0,
                                          (char) CommonEnums.ORDER_SESSION.SESSION0
                                      };
            try
            {
                orderSessions = ETradeServices.GetAllOrderSession();
                var resultObject = new ResultObject<char[]>
                {
                    Result = orderSessions,
                    RetCode = CommonEnums.RET_CODE.SUCCESS,
                };

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<char[]>
                            {
                                Result = orderSessions,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                            });
            }
        }

        #endregion
        #region balance
        /// <summary>
        /// Get portfolio of an investor. This is list stock available in portfolio, includes
        /// 1. Sellable stock
        /// 2. Pledge stock
        /// 3. Limittransfer
        /// 4. Wait to receive intra-day
        /// 5. Wait to send intra-day
        /// 6. Wait to receive T1, T2, T3
        /// 7. Wait to send T1, T2, T3
        /// </summary>
        /// <param name="accountNo">
        /// The account no.
        /// </param>
        /// <param name="pageNumber">
        /// The page number.
        /// </param>
        /// <param name="pageSize">
        /// The page size.
        /// </param>
        /// <param name="accountType">
        /// The account type.
        /// </param>
        /// <returns>
        /// <para>A <see cref="ResultObject{T}">ResultObject&lt;PagingObject&lt;List&lt;PortfolioInfo&gt;, PortfolioInfo, PortfolioInfo&gt;&gt;</see> object contains returned code, returned message and 
        /// list of portfolio objects.</para>
        /// <para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// <para>RET_CODE=ERROR_ACCOUNT: The account does not exist.</para>
        /// <para>RET_CODE=NO_EXISTED_DATA: There is no data.</para>
        /// <para>RET_CODE=SUCCESS: Getting data successfully.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Get portfolio - stock balance of an investor (it for statement), accountType: 1 for normal account, 1 for margin account", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string GetPortfolio(string accountNo, int pageNumber, int pageSize, int accountType,string apiKey)
        {
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<PagingObject<List<PortfolioInfo>, PortfolioInfo, PortfolioInfo>>
                            {
                                Result = new PagingObject<List<PortfolioInfo>, PortfolioInfo, PortfolioInfo>(),
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                        });
                }
                //Check multiple account by an customer
                if (IsMultiAccount(string.Empty, accountNo))
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<PagingObject<List<PortfolioInfo>, PortfolioInfo, PortfolioInfo>>
                            {
                                Result = new PagingObject<List<PortfolioInfo>, PortfolioInfo, PortfolioInfo>(),
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                var subCustAccount = (SubCustAccount)Session[accountNo + CommonEnums.SESSION_KEY.TRADING_ACCOUNT];

                if (subCustAccount == null)
                {
                    return Serializer.Serialize(
                            new ResultObject<PagingObject<List<PortfolioInfo>, PortfolioInfo, PortfolioInfo>>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.ERROR_ACCOUNT,
                                ErrorMessage = CommonEnums.RET_CODE.ERROR_ACCOUNT.ToString()
                            });
                }
                var subCustAccounts = (List<string>)Session[CommonEnums.SESSION_KEY.LIST_SUB_ACCOUNTS.ToString()];
                ResultObject<PagingObject<List<PortfolioInfo>, PortfolioInfo, PortfolioInfo>> resultObject = ETradeServices.GetPortfolio(
                    accountNo, pageNumber, pageSize, accountType, subCustAccount, subCustAccounts);

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<PagingObject<List<PortfolioInfo>, PortfolioInfo, PortfolioInfo>>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                            });
            }
        }
        /// <summary>
        /// Get list of portfolio of an investor. This is list stock available in portfolio, includes
        /// 1. Sellable stock
        /// 2. Pledge stock
        /// 3. Limittransfer
        /// 4. Wait to receive intra-day
        /// 5. Wait to send intra-day
        /// 6. Wait to receive T1, T2, T3
        /// 7. Wait to send T1, T2, T3
        /// </summary>
        /// <param name="accountNo">
        /// The account no.
        /// </param>
        /// <param name="accountType">
        /// The account type.
        /// </param>
        /// <returns>
        /// <para>A ResultObject&lt;PagingObject&lt;List&lt;string&gt;&gt;&gt; object contains returned code, 
        /// returned message and a list of portfolios.</para>
        /// <para>RET_CODE=NOT_LOGIN: User has not logged in.</para>
        /// <para>RET_CODE=ERROR_ACCOUNT: Data of user does not exist.</para>
        /// <para>RET_CODE=SUCCESS: Create data successfully.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Get portfolio - stock balance of an investor (it for statement), accountType: 0 for normal account, 1 for margin account", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string GetListPortfolio(string accountNo, int accountType,string apiKey)
        {
            var resultObject = new ResultObject<List<string>>();
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    resultObject.Result = null;
                    resultObject.RetCode = CommonEnums.RET_CODE.NOT_LOGIN;
                    resultObject.ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString();
                    return Serializer.Serialize(resultObject);
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                        });
                }
                var subCustAccount = (SubCustAccount)Session[accountNo + CommonEnums.SESSION_KEY.TRADING_ACCOUNT];

                if (subCustAccount == null)
                {
                    resultObject.Result = null;
                    resultObject.RetCode = CommonEnums.RET_CODE.ERROR_ACCOUNT;
                    resultObject.ErrorMessage = CommonEnums.RET_CODE.ERROR_ACCOUNT.ToString();
                    return Serializer.Serialize(resultObject);
                }

                //Check multiple account by an customer
                if (IsMultiAccount(string.Empty, accountNo))
                {
                    resultObject.Result = null;
                    resultObject.RetCode = CommonEnums.RET_CODE.NOT_LOGIN;
                    resultObject.ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString();
                    return Serializer.Serialize(resultObject);
                }

                var listPortfolio = ETradeServices.GetListPortfolio(accountNo, accountType);
                resultObject.Result = listPortfolio;
                resultObject.RetCode = CommonEnums.RET_CODE.SUCCESS;
                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                resultObject.Result = null;
                resultObject.RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR;
                resultObject.ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString();
                return Serializer.Serialize(resultObject);
            }
        }

        /// <summary>
        /// Get cash available os an investor. There are some account types:
        /// 1. Normal account (cash account with 1 in rail): There just BuyCredit
        /// 2. Margin account (with 6 in rail): There BuyCredit, PP, IM
        /// And other accounts
        /// </summary>
        /// <param name="subAccountNo">The account no.</param>
        /// <param name="accountType">The account type.</param>
        /// <param name="isConditionOrder">if set to <c>true</c> [is condition order].</param>
        /// <returns>
        /// 	<para>A <see cref="ResultObject{T}">ResultObject&lt;CashAvailable&gt;</see> object contains returned code, returned message and
        /// list of CashAvailable objects that contains available cash information.</para>
        /// 	<para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// 	<para>RET_CODE=ERROR_NOT_CASH_AVAILABLE: There is no data.</para>
        /// 	<para>RET_CODE=SUCCESS: Get data successfully.</para>
        /// 	<para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(
            Description = "Get available cash for buy order, accountType = 0 for normal account, 1 for margin account",
            EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string GetAvailableCash(string subAccountNo, int accountType, bool isConditionOrder,string apiKey)
        {
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<CashAvailable>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                        });
                }
                //Check multiple account by an customer
                if (IsMultiAccount(string.Empty, subAccountNo))
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<CashAvailable>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                ResultObject<CashAvailable> cashAvailable = ETradeServices.GetAvailableCash(subAccountNo, accountType, isConditionOrder);

                return Serializer.Serialize(cashAvailable);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<CashAvailable>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                            });
            }
        }
        /// <summary>
        /// Get available stock of an investor. This just sellable share
        /// </summary>
        /// <param name="subAccountNo">The account no.</param>
        /// <param name="symbol">The symbol.</param>
        /// <param name="accountType">The account type.</param>
        /// <param name="?">The ?.</param>
        /// <param name="isConditionOrder">if set to <c>true</c> [is condition order].</param>
        /// <returns>
        /// 	<para>A <see cref="ResultObject{T}">ResultObject&lt;StockAvailable&gt;</see> object contains returned code, returned message and
        /// list of StockAvailable objects that contains available stock information.</para>
        /// 	<para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// 	<para>RET_CODE=ERROR_NOT_STOCK_AVAILABLE: There is no data.</para>
        /// 	<para>RET_CODE=SUCCESS: Get data successfully.</para>
        /// 	<para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Get stock available of a specified symbol for sell order, accountType: 0 for normal account, 1 for margin account", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string GetAvailableStock(string subAccountNo, string symbol, int accountType, bool isConditionOrder,string apiKey)
        {
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<StockAvailable>
                            {
                                Result = new StockAvailable(),
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                        });
                }
                //Check multiple account by an customer
                if (IsMultiAccount(string.Empty, subAccountNo))
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<StockAvailable>
                            {
                                Result = new StockAvailable(),
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                var resultObject = ETradeServices.GetAvailableStock(subAccountNo, symbol, accountType, isConditionOrder);

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<StockAvailable>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                            });
            }
        }
        /// <summary>
        /// Get cash balance of an investor. This includes:
        /// 1. Buycredit
        /// 2. CashBalance for margin account
        /// 3. PP, IM for margin account
        /// 4. Withdraw
        /// 5. Net amount of T1, T2, T3
        /// 6. Total buy intra-day
        /// 7. Total sell intra-day
        /// </summary>
        /// <param name="subAccountNo">The account no.</param>
        /// <param name="accountType">The account type.</param>
        /// <returns>
        /// 	<para>A <see cref="ResultObject{T}">ResultObject&lt;CashBalance;&gt;</see> object contains returned code, returned message and
        /// CashAdvance object that contains cash advance information.</para>
        /// 	<para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// 	<para>RET_CODE=NO_EXISTED_DATA: There is no data.</para>
        /// 	<para>RET_CODE=SUCCESS: Get data successfully.</para>
        /// 	<para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Get cash balance information (it for statement), accountType: 0 for normal account, 1 for margin account", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string GetCashBalance(string subAccountNo, int accountType,string apiKey)
        {
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<CashBalance>
                            {
                                Result = new CashBalance(),
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                        });
                }
                //Check multiple account by an customer
                if (IsMultiAccount(string.Empty, subAccountNo))
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<CashBalance>
                            {
                                Result = new CashBalance(),
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                var resultObject = ETradeServices.GetCashBalance(subAccountNo, accountType);

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<CashBalance>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                            });
            }
        }

        /// <summary>
        /// Gets the portfolio direct.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <param name="accountType">Type of the account.</param>
        /// <returns>
        /// <para>A <see cref="ResultObject{T}">ResultObject&lt;List&lt;Portfolio&gt;&gt;</see> object contains returned code, returned message and 
        /// list of portfolio objects.</para>
        /// <para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// <para>RET_CODE=SUCCESS: Getting data successfully.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Get portfolio information. This option for accessing direct table", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string GetPortfolioDirect(string accountNo, int accountType,string apiKey)
        {
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<List<Portfolio>>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                        });
                }
                //Check multiple account by an customer
                if (IsMultiAccount(string.Empty, accountNo))
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<List<Portfolio>>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                var resultObject = ETradeServices.GetPortfolioDirect(accountNo, accountType);

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<List<Portfolio>>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                            });
            }
        }

        #endregion
        #region check account methods
        /// <summary>
        /// Check if user is using multiple accounts or not.
        /// </summary>
        /// <param name="sendingMainCustAccountId">Main customer account id sent from website</param>
        /// <param name="sendingSubCustAccountId">Sub customer account id sent from website</param>
        /// <returns>true: if using multiple account; otherwise false.</returns>
        private bool IsMultiAccount(string sendingMainCustAccountId, string sendingSubCustAccountId)
        {
            if (!string.IsNullOrEmpty(sendingMainCustAccountId))
            {
                var mainCustAccountId = (string)Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()];
                if (mainCustAccountId != sendingMainCustAccountId)
                {
                    return true;
                }
            }
            if (!string.IsNullOrEmpty(sendingSubCustAccountId))
            {
                var subCustAccountIdList = (List<string>)Session[CommonEnums.SESSION_KEY.LIST_SUB_ACCOUNTS.ToString()];
                if (subCustAccountIdList != null)
                {
                    foreach (var subId in subCustAccountIdList)
                    {
                        if (subId == sendingSubCustAccountId)
                        {
                            return false;
                        }
                    }
                }
                return true;
            }
            return false;
        }
        #endregion check account methods
        #region order
        /// <summary>
        /// Puts new order.
        /// </summary>
        /// <param name="market">
        /// The market id. Please refer to the enum MARKET_ID in CommonEnums.cs to know the values.
        /// </param>
        /// <param name="accountNo">
        /// The sub account ID such as 0088661, 0088666
        /// </param>
        /// <param name="pin">
        /// The pin code
        /// </param>
        /// <param name="secSymbol">
        /// The sec symbol of HOSE/HNX/UpCom
        /// </param>
        /// <param name="side">
        /// The side includes values BUY: "B", SELL: "S". Please refer to the enum TRADE_SIDE in CommonEnums.cs to know the values.
        /// </param>
        /// <param name="volume">
        /// The volume.
        /// </param>
        /// <param name="price">
        /// The price.
        /// </param>
        /// <param name="conPrice">
        /// The con price includes values ATO: 'A', ATC: 'C', LO: ' '. Please refer to the enum TRADE_SIDE in Constants.cs to know the values.
        /// </param>
        /// <param name="accountType">
        /// Type of the account includes values Normal account (such as 0088661): 0, Margin account (such as 0088666): 1
        /// </param>
        /// <param name="orderSource">Order source: From web or sms.</param>
        /// <returns>
        /// <para>
        /// Result of putting order.
        /// If the RetCode is CommonEnums.RET_CODE.SUCCESS then Result of ResultObject is the order id.
        /// Otherwise, it is a reject code. Please refer to the reject code in the enum REJECT_REASON of CommonEnums.cs
        /// </para>
        /// <para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// <para>RET_CODE=INCORRECT_PIN: The pin is incorrect.</para>
        /// <para>RET_CODE=ERROR_ACCOUNT: Account does not exist.</para>
        /// <para>RET_CODE=ERROR_GW_NOT_CONNECTED: LinkOPS hasn't been connected.</para>
        /// <para>RET_CODE=ERROR_GW_NOT_SEND: Sending message failed.</para>
        /// <para>RET_CODE=SUCCESS: Putting order successfully.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// <para>REJECT_REASON</para>
        /// <para>REJECT_REASON=ERROR_MARGIN_ACCOUNT_CANNOT_BUY_THAT_SYMBOL: Margin account cannot buy this symbol.</para>
        /// <para>REJECT_REASON=ERROR_OVER_LIMIT_LOAN_PER_CUSTOMER: The value of price after fee overs the limit of loan per customer.</para>
        /// <para>REJECT_REASON=ERROR_OVER_LIMIT_LOAN_PER_SECSYMBOL: The value of price after fee over the limit of loan per symbol.</para>
        /// <para>REJECT_REASON=ERROR_OVER_LIMIT_COMPANY_CAPITAL: The value of price after fee over the limit of the company capital.</para>
        /// <para>REJECT_REASON=ERROR_OVER_LIMIT_MAX_BUY: The value of price after fee over max buy of that account.</para>
        /// <para>REJECT_REASON=ERROR_OVER_LIMIT_MAX_BUY_OF_SECSYMBOL: The value of price after fee over max buy of symbol.</para>
        /// <para>REJECT_REASON=ERROR_MARKET_CLOSE: Market closed.</para>
        /// <para>REJECT_REASON=ERROR_ATO_NOT_IN_READY_AND_SESSION1: Cannot put ATO order in READY and SESSION1 session.</para>
        /// <para>REJECT_REASON=ERROR_ATC_NOT_IN_SESSION3: Cannot put ATC in SESSION3 session.</para>
        /// <para>REJECT_REASON=ERROR_PRICE_NOT_MULTIPLE_100_FOR_HOSE: Price is incorrect for HOSE market.</para>
        /// <para>REJECT_REASON=ERROR_PRICE_NOT_MULTIPLE_500_FOR_HOSE: Price is incorrect for HOSE market.</para>
        /// <para>REJECT_REASON=ERROR_PRICE_NOT_MULTIPLE_1000_FOR_HOSE: Price is incorrect for HOSE market.</para>
        /// <para>REJECT_REASON=ERROR_HNX_NOT_USE_ATO_ATC: Cannot put ATO, ATC order in HNX market.</para>
        /// <para>REJECT_REASON=ERROR_PRICE_NOT_MULTIPLE_100_FOR_HNX: Price is incorrect for HNX market.</para>
        /// <para>REJECT_REASON=ERROR_UPCOM_NOT_USE_ATO_ATC: Cannot put ATO, ATC order in UPCOM market.</para>
        /// <para>REJECT_REASON=ERROR_PRICE_NOT_MULTIPLE_100_FOR_UPCOM: Price is incorrect for UPCOM market.</para>
        /// <para>REJECT_REASON=INCORRECT_SIDE: The side is not buy or sell side.</para>
        /// <para>REJECT_REASON=INCORRECT_VOL: The volume is incorrect.</para>
        /// <para>REJECT_REASON=OVER_MAX_VOL: The volume is over max allowed volume.</para>
        /// <para>REJECT_REASON=INCORRECT_STOCK: Stock is incorrect.</para>
        /// <para>REJECT_REASON=STOCK_IS_HALT: Stock is halt.</para>
        /// <para>REJECT_REASON=PRICE_BELOW_FLOOR: Price is below floor price.</para>
        /// <para>REJECT_REASON=PRICE_ABOVE_CEILING: Price is over ceiling price.</para>
        /// <para>REJECT_REASON=NOT_BUY_SELL_THE_SAME_STOCK: Not allow to buy and sell the same stock.</para>
        /// <para>REJECT_REASON=ERROR_LOCK_ACCOUNT: Account is locked.</para>
        /// <para>REJECT_REASON=ERROR_ACCOUNT_NOT_BUY_PERMISSION: Account is not allowed to buy stocks.</para>
        /// <para>REJECT_REASON=ERROR_ACCOUNT_NOT_SELL_PERMISSION: Account is not allowed to sell stocks.</para>
        /// <para>REJECT_REASON=NOT_ENOUGH_CASH: Customer has not enough money.</para>
        /// <para>REJECT_REASON=NOT_ENOUGH_STOCK: Customer has not enough stocks.</para>
        /// <para>REJECT_REASON=OVER_REMAIN_VOLUME: Available volume is not enough.</para>
        /// <para>REJECT_REASON=IS_VALID: This is a valid order.</para>
        /// </returns>
        [WebMethod(Description = "Put Order, return a ResultObject<Integer>", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string PutOrder(int market, string accountNo, string pin, string secSymbol, char side, int volume,
            decimal price, char conPrice, int accountType, char orderSource,string apiKey)
        {
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    return Serializer.Serialize(
                            new ResultObject<int>
                            {
                                Result = -1,
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                        });
                }
                if (Session[accountNo + CommonEnums.SESSION_KEY.TRADING_ACCOUNT] == null)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<int>
                            {
                                ErrorMessage = CommonEnums.RET_CODE.ERROR_ACCOUNT.ToString(),
                                Result = (int)CommonEnums.RET_CODE.ERROR_ACCOUNT,
                                RetCode = CommonEnums.RET_CODE.ERROR_ACCOUNT
                            });
                }
                //Check multiple account by an customer
                if (IsMultiAccount(string.Empty, accountNo))
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<int>
                            {
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString(),
                                Result = (int)CommonEnums.RET_CODE.NOT_LOGIN,
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN
                            });
                }
                string sessionPin = Session[CommonEnums.SESSION_KEY.PIN.ToString()].ToString();

                if (PasswordHandlerMd5.Encrypt(pin) != sessionPin)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<int>
                            {
                                ErrorMessage = CommonEnums.RET_CODE.INCORRECT_PIN.ToString(),
                                Result = (int)CommonEnums.RET_CODE.FAIL,
                                RetCode = CommonEnums.RET_CODE.INCORRECT_PIN
                            });
                }

                var subCustAccount = (SubCustAccount)Session[accountNo + CommonEnums.SESSION_KEY.TRADING_ACCOUNT];

                var subCustAccounts = (List<string>)Session[CommonEnums.SESSION_KEY.LIST_SUB_ACCOUNTS.ToString()];

                int customerType;
                customerType = int.TryParse(Session[CommonEnums.SESSION_KEY.CUSTOMER_TYPE.ToString()].ToString(),
                                            out customerType)
                                   ? customerType
                                   : (int)CommonEnums.CUSTOMER_TYPE.INTERNAL;

                ResultObject<int> resultObject = ETradeServices.PutOrder(market, accountNo, secSymbol, side, volume,
                                                                         price, conPrice, accountType, customerType,
                                                                         subCustAccount, subCustAccounts, orderSource);

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<int>
                            {
                                Result = -1,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                            });
            }
        }

        /// <summary>
        /// Cancels an existed order. This order must is pending or is already confirmed from SET or FIS
        /// </summary>
        /// <param name="orderId">The order id that was return by PutOrder APIs</param>
        /// <param name="accountNo">The sub accountId such as 0088661, 0088666</param>
        /// <param name="pin">The pin code</param>
        /// <returns>
        /// <para>ResultObject of interger. 
        /// If the RetCode is CommonEnums.RET_CODE.SUCCESS then Result of ResultObject is the order id.
        /// Otherwise, it is a reject code. Please refer to the reject code in the enum REJECT_REASON of CommonEnums.cs</para>
        /// <para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// <para>RET_CODE=INCORRECT_PIN: The pin is incorrect.</para>
        /// <para>RET_CODE=NO_EXISTED_DATA: There is no data.</para>
        /// <para>RET_CODE=ERROR_CANNOT_CANCEL_ODD_LOT_ORDER: Cannot cancel odd lot order because it's in incorrect state.</para>
        /// <para>RET_CODE=SUCCESS: Cancel successfully.</para>
        /// <para>RET_CODE=FAIL: Fail to cancel odd lot order.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Cancel Order, return a ResultObject<Integer>", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string CancelOrder(int orderId, string accountNo, string pin,string apiKey)
        {
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<int>
                            {
                                Result = -1,
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                        });
                }
                string sessionPin = Session[CommonEnums.SESSION_KEY.PIN.ToString()].ToString();

                if (PasswordHandlerMd5.Encrypt(pin) != sessionPin)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<int>
                            {
                                ErrorMessage = CommonEnums.RET_CODE.INCORRECT_PIN.ToString(),
                                Result = (int)CommonEnums.RET_CODE.FAIL,
                                RetCode = CommonEnums.RET_CODE.INCORRECT_PIN
                            });
                }

                ResultObject<int> resultObject = ETradeServices.CancelOrder(orderId);

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<int>
                            {
                                Result = -1,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR
                            });
            }

        }
        /// <summary>
        /// Gets all the newest order information that put to system from all sources.
        /// </summary>
        /// <param name="pageSize">Size of the page.</param> 
        /// <param name="pageIndex">The page number. if pageIndex = 0, it will return all orders</param>
        /// <param name="accountNo">The account no.</param>
        /// <param name="isPending">You want it to return the pending orders. Values is True/False.</param>
        /// <param name="isMatched">You want it to return the matched orders. Values is True/False.</param>
        /// <param name="isSemiMatched">You want it to return the semimatched orders. Values is True/False.</param>
        /// <param name="isCanceling">You want it to return the canceling orders. Values is True/False.</param>
        /// <param name="isCancelled">You want it to return the canceled orders. Values is True/False.</param>
        /// <param name="isRejected">You want it to return the rejected orders. Values is True/False.</param>
        /// <returns>
        /// <para>A <see cref="ResultObject{T}">ResultObject&lt;PagingObject&lt;List&lt;ExecOrder&gt;&gt;&gt;</see> object contains returned code, returned message and 
        /// list of ExecOrder objects that contains order information.</para>
        /// <para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// <para>RET_CODE=NO_EXISTED_DATA: There is no data.</para>
        /// <para>RET_CODE=SUCCESS: Putting order successfully.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Get newest order status Order. Return ResultObject<PagingObject<List<ExecOrder>>>", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string NewestOrdStatus(int pageSize, int pageIndex, string accountNo,
                                             bool isPending, bool isMatched, bool isSemiMatched, bool isCanceling, bool isCancelled, bool isRejected,string apiKey)
        {
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<PagingObject<List<ExecOrder>>>
                            {
                                Result = new PagingObject<List<ExecOrder>>(),
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                        });
                }
                //Check multiple account by an customer
                if (IsMultiAccount(string.Empty, accountNo))
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<PagingObject<List<ExecOrder>>>
                            {
                                Result = new PagingObject<List<ExecOrder>>(),
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                ResultObject<PagingObject<List<ExecOrder>>> resultObject = ETradeServices.GetNewsestOrderStatus(pageSize, pageIndex, accountNo, isPending, isMatched, isSemiMatched, isCanceling, isCancelled, isRejected);
                if (resultObject.RetCode == CommonEnums.RET_CODE.SUCCESS)
                {
                    var listOrders = resultObject.Result.Data;

                    resultObject.Result.isNew = IsOrdersUpdated(listOrders);
                }
                else
                {
                    resultObject.Result.isNew = false;
                }

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<PagingObject<List<ExecOrder>>>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR
                            });
            }
        }
        /// <summary>
        /// Compare to find out the different between new and old order status. Update new ones to sesssion
        /// </summary>
        /// <param name="listOrders">Order list to check.</param>
        /// <returns>true if the order list is new; otherwise false.</returns>
        private Boolean IsOrdersUpdated(List<ExecOrder> listOrders)
        {
            if (listOrders == null || listOrders.Count == 0)
                return false;

            if (Session[CommonEnums.SESSION_KEY.STOCK_ORDERS.ToString()] == null)
            {
                Session[CommonEnums.SESSION_KEY.STOCK_ORDERS.ToString()] = listOrders;

                return true;
            }

            var oldListOrders = (List<ExecOrder>)Session[CommonEnums.SESSION_KEY.STOCK_ORDERS.ToString()];

            if (listOrders.Count != oldListOrders.Count)
            {
                Session[CommonEnums.SESSION_KEY.STOCK_ORDERS.ToString()] = listOrders;

                return true;
            }

            for (int index = 0; index < listOrders.Count; index++)
            {
                ExecOrder oldItem = oldListOrders[index];
                ExecOrder newItem = listOrders[index];

                if (oldItem.OrderId != newItem.OrderId ||
                    oldItem.OrderStatus != newItem.OrderStatus ||
                    oldItem.NumOfMatch != newItem.NumOfMatch ||
                    oldItem.canCancel != newItem.canCancel)
                {
                    Session[CommonEnums.SESSION_KEY.STOCK_ORDERS.ToString()] = listOrders;

                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Gets the total orders that put to system from all sources.
        /// </summary>
        /// <param name="accountId">The account no.</param>
        /// <param name="isPending">You want it to return the pending orders. Values is True/False.</param>
        /// <param name="isMatched">You want it to return the matched orders. Values is True/False.</param>
        /// <param name="isSemiMatched">You want it to return the semimatched orders. Values is True/False.</param>
        /// <param name="isCanceling">You want it to return the canceling orders. Values is True/False.</param>
        /// <param name="isCancelled">You want it to return the canceled orders. Values is True/False.</param>
        /// <param name="isRejected">You want it to return the rejected orders. Values is True/False.</param>
        /// <returns>
        /// <para>A <see cref="ResultObject{T}">ResultObject&lt;int&gt;</see> object contains returned code, returned message and 
        /// total records.</para>
        /// <para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// <para>RET_CODE=SUCCESS: Putting order successfully.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Get newest order status Order", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string NewestOrdCount(string accountId, bool isPending, bool isMatched, bool isSemiMatched, bool isCanceling, bool isCancelled, bool isRejected,string apiKey)
        {
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<int>
                            {
                                Result = -1,
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                        });
                }
                //Check multiple account by an customer
                if (IsMultiAccount(string.Empty, accountId))
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<int>
                            {
                                Result = -1,
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                ResultObject<int> resultObject = ETradeServices.GetNewsestOrderCount(accountId, isPending, isMatched, isSemiMatched, isCanceling, isCancelled, isRejected);

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<int>
                            {
                                Result = -1,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR
                            });
            }
        }

        /// <summary>
        /// Get order history of an investor
        /// </summary>
        /// <param name="accountNo">
        /// The sub account no. such as 0088661, 0088666
        /// </param>
        /// <param name="fromDate">
        /// The from date. Format(YYYYMMDD)
        /// </param>
        /// <param name="toDate">
        /// The to date. Format(YYYYMMDD)
        /// </param>
        /// <param name="symbol">
        /// The symbol.
        /// </param>
        /// <param name="orderStatus">
        /// The order status. please refer the values from FILTER_ORDER_STATUS in CommonEnums.cs
        /// </param>
        /// <param name="pageIndex">
        /// The page index. if pageIndex = 0 then it will return all results.
        /// </param>
        /// <param name="pageSize">
        /// The page size.
        /// </param>
        /// <returns>
        /// <para>A <see cref="ResultObject{T}">ResultObject&lt;PagingObject&lt;List&lt;OrderHistory&gt;&gt;&gt;</see> object contains returned code, returned message and 
        /// list of OrderHistory objects.</para>
        /// <para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// <para>RET_CODE=ERROR_INVALID_DATETIME: The date is invalid.</para>
        /// <para>RET_CODE=NO_EXISTED_DATA: There is no data.</para>
        /// <para>RET_CODE=SUCCESS: Getting data successfully.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Get order history", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string GetOrderHistory(string accountNo, string fromDate, string toDate, string symbol, int orderStatus, int pageIndex, int pageSize,string apiKey)
        {
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<PagingObject<List<OrderHistory>>>
                            {
                                Result = new PagingObject<List<OrderHistory>>(),
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                        });
                }
                //Check multiple account by an customer
                if (IsMultiAccount(string.Empty, accountNo))
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<PagingObject<List<OrderHistory>>>
                            {
                                Result = new PagingObject<List<OrderHistory>>(),
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                var resultObject = ETradeServices.GetOrderHistory(accountNo, fromDate, toDate, symbol, orderStatus, pageIndex, pageSize);

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<PagingObject<List<OrderHistory>>>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                            });
            }
        }

        /// <summary>
        /// Gets the order history count.
        /// </summary>
        /// <param name="accountNo">
        /// The sub account no. such as 0088661, 0088666
        /// </param>
        /// <param name="fromDate">
        /// The from date. Format(YYYYMMDD)
        /// </param>
        /// <param name="toDate">
        /// The to date. Format(YYYYMMDD)
        /// </param>
        /// <param name="symbol">
        /// The symbol.
        /// </param>
        /// <param name="orderStatus">
        /// The order status. please refer the values from FILTER_ORDER_STATUS in CommonEnums.cs
        /// </param>
        /// <returns>
        /// <para>A <see cref="ResultObject{T}">ResultObject&lt;int&gt;</see> object contains returned code, returned message and 
        /// total records.</para>
        /// <para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// <para>RET_CODE=NO_EXISTED_DATA: There is no data.</para>
        /// <para>RET_CODE=SUCCESS: Getting data successfully.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Get order history count, return ResultObject<int>", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string GetOrderHistoryCount(string accountNo, string fromDate, string toDate, string symbol, int orderStatus,string apiKey)
        {
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<int>
                            {
                                Result = 0,
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                        });
                }
                //Check multiple account by an customer
                if (IsMultiAccount(string.Empty, accountNo))
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<int>
                            {
                                Result = 0,
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                var resultObject = ETradeServices.GetOrderHistoryCount(accountNo, fromDate, toDate, symbol, orderStatus);

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<int>
                            {
                                Result = -1,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                            });
            }
        }
        /// <summary>
        /// Get deal detail of order history
        /// </summary>
        /// <param name="orderNo">
        /// The order no that was returned by GetOrderHistory.
        /// </param>
        /// <param name="dealDate">
        /// The deal date. Format (YYYYMMDD)
        /// </param>
        /// <param name="page">
        /// The page. page = 0 is all.
        /// </param>
        /// <returns>
        /// <para>A <see cref="ResultObject{T}">ResultObject&lt;List&lt;DealHistory&gt;&gt;</see> object contains returned code, returned message and 
        /// list of DealHistory object that contains deal history information.</para>
        /// <para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// <para>RET_CODE=ERROR_INVALID_DATETIME: The dealDate is invalid.</para>
        /// <para>RET_CODE=NO_EXISTED_DATA: There is no data.</para>
        /// <para>RET_CODE=SUCCESS: Get data successfully.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Get deal history, return ResultObject<List<DealHistory>>", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string GetDealHistory(decimal orderNo, string dealDate, int page,string apiKey)
        {
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<List<DealHistory>>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                        });
                }
                var resultObject = ETradeServices.GetDealHistory(orderNo, dealDate, page);

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<List<DealHistory>>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                            });
            }
        }
        /// <summary>
        /// Gets the deal intra day.
        /// </summary>
        /// <param name="orderNo">The order no that was returned by PutOrder.</param>
        /// <param name="page">The page. If page = 0, it return all results.</param>
        /// <returns>
        /// <para>A <see cref="ResultObject{T}">ResultObject&lt;List&lt;DealInfo&gt;&gt;</see> object contains returned code, returned message and 
        /// list of DealInfo object that contains deal information.</para>
        /// <para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// <para>RET_CODE=ERROR_INVALID_DATETIME: The dealDate is invalid.</para>
        /// <para>RET_CODE=NO_EXISTED_DATA: There is no data.</para>
        /// <para>RET_CODE=SUCCESS: Get data successfully.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Get deal information for intra-day, return ResultObject<List<DealInfo>>", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string GetDealIntraDay(decimal orderNo, int page,string apiKey)
        {
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<List<DealInfo>>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                        });
                }
                var resultObject = ETradeServices.GetDealIntraDay(orderNo, page);

                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<List<DealInfo>>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                            });
            }
        }

        /// <summary>
        /// Gets the information that support for user that can refer before puting order.
        /// </summary>
        /// <param name="accountNo">The sub account no. Such as 0088661, 0088666</param>
        /// <param name="symbol">The symbol of HOSE/HNX/UPCOM</param>
        /// <param name="accountType">Type of the account.
        /// 0: is normal account (such as 0088661).
        /// 1: is margin account (such as 0088666).
        /// Please refer to ACCOUNT_TYPE in CommonEnums.cs</param>
        /// <param name="side">The side of trading.
        /// 'B': buy, 'S': sell.
        /// Please refer to TRADE_SIDE in CommonEnums.cs</param>
        /// <param name="isConditionOrder">if set to <c>true</c> [is condition order].</param>
        /// <returns>
        /// 	<para>A <see cref="ResultObject{T}">ResultObject&lt;PreTradeInfo&gt;</see> object contains returned code, returned message and
        /// pretrade information.</para>
        /// 	<para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// 	<para>RET_CODE=SUCCESS: Getting data successfully.</para>
        /// 	<para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Get pre trade information, it includes: stock available, cash available, stock information, tradign state", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string GetPreTradeInfo(string accountNo, string symbol, int accountType, char side, bool isConditionOrder,string apiKey)
        {
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<PreTradeInfo>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                        });
                }
                //Check multiple account by an customer
                if (IsMultiAccount(string.Empty, accountNo))
                {
                    return
                        Serializer.Serialize(
                            new ResultObject<PreTradeInfo>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.NOT_LOGIN,
                                ErrorMessage = CommonEnums.RET_CODE.NOT_LOGIN.ToString()
                            });
                }
                var resultObject = ETradeServices.GetPreTradeInfo(accountNo, symbol, accountType, side, isConditionOrder);
                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return Serializer.Serialize(
                            new ResultObject<PreTradeInfo>
                            {
                                Result = null,
                                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                                ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                            });
            }
        }

        /// <summary>
        /// Put advance orders.
        /// </summary>
        /// <param name="market">Market Id</param>
        /// <param name="accountNo">Sub account Id</param>
        /// <param name="pin">Pin</param>
        /// <param name="secSymbol">security symbol</param>
        /// <param name="side">Side "B":buy; "S":Sell</param>
        /// <param name="volume">Volume to trade</param>
        /// <param name="price">Price to trade</param>
        /// <param name="strEffDate">Effected date </param>
        /// <param name="strExpDate">Expired date</param>
        /// <param name="type">Type of advance order</param>
        /// <param name="minValue">Minimum price value</param>
        /// <param name="maxValue">Maximum price value</param>
        /// <returns>
        /// <para>
        /// Result of putting advance order.
        /// If the RetCode is CommonEnums.RET_CODE.SUCCESS then Result of ResultObject is the order id.
        /// Otherwise, it is a reject code. Please refer to the reject code in the enum REJECT_REASON of CommonEnums.cs
        /// </para>
        /// <para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// <para>RET_CODE=INCORRECT_PIN: The pin is incorrect.</para>
        /// <para>RET_CODE=ERROR_ACCOUNT: Account does not exist.</para>
        /// <para>RET_CODE=NOT_ALLOW: Customer isn't allowed to buy or sell stock.</para>
        /// <para>RET_CODE=SUCCESS: Putting order successfully.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// <para>REJECT_REASON</para>
        /// <para>REJECT_REASON=NOT_ADVANCE_TIME: This time is not advance time.</para>
        /// <para>REJECT_REASON=ERROR_PRICE_NOT_MULTIPLE_100_FOR_HOSE: Price is incorrect for HOSE market.</para>
        /// <para>REJECT_REASON=ERROR_PRICE_NOT_MULTIPLE_500_FOR_HOSE: Price is incorrect for HOSE market.</para>
        /// <para>REJECT_REASON=ERROR_PRICE_NOT_MULTIPLE_1000_FOR_HOSE: Price is incorrect for HOSE market.</para>
        /// <para>REJECT_REASON=ERROR_HNX_NOT_USE_ATO_ATC: Cannot put ATO, ATC order in HNX market.</para>
        /// <para>REJECT_REASON=ERROR_PRICE_NOT_MULTIPLE_100_FOR_HNX: Price is incorrect for HNX market.</para>
        /// <para>REJECT_REASON=ERROR_UPCOM_NOT_USE_ATO_ATC: Cannot put ATO, ATC order in UPCOM market.</para>
        /// <para>REJECT_REASON=ERROR_PRICE_NOT_MULTIPLE_100_FOR_UPCOM: Price is incorrect for UPCOM market.</para>
        /// <para>REJECT_REASON=INCORRECT_SIDE: The side is not buy or sell side.</para>
        /// <para>REJECT_REASON=INCORRECT_VOL: The volume is incorrect.</para>
        /// <para>REJECT_REASON=OVER_MAX_VOL: The volume is over max allowed volume.</para>
        /// <para>REJECT_REASON=INCORRECT_STOCK: Stock is incorrect.</para>
        /// <para>REJECT_REASON=STOCK_IS_HALT: Stock is halt.</para>
        /// <para>REJECT_REASON=ERROR_LOCK_ACCOUNT: Account is locked.</para>
        /// <para>REJECT_REASON=ERROR_ACCOUNT_NOT_CONDITION_ORDER: Account is not allowed to put advance order.</para>
        /// <para>REJECT_REASON=NOT_ENOUGH_CASH: Customer has not enough money.</para>
        /// <para>REJECT_REASON=NOT_ENOUGH_STOCK: Customer has not enough stocks.</para>
        /// <para>REJECT_REASON=IS_VALID: This is a valid order.</para>
        /// </returns>
        [WebMethod(Description = "Put advance orders for a range of days", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string PutAdvanceOrder(int market, string accountNo, string pin, string secSymbol, char side, int volume, decimal price, string strEffDate, string strExpDate, short type, decimal minValue, decimal maxValue,string apiKey)
        {
            var resultObject = new ResultObject<int>();
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    resultObject.RetCode = CommonEnums.RET_CODE.NOT_LOGIN;
                    return Serializer.Serialize(resultObject);
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                        });
                }
                if (Session[accountNo + CommonEnums.SESSION_KEY.TRADING_ACCOUNT] == null)
                {
                    resultObject.RetCode = CommonEnums.RET_CODE.ERROR_ACCOUNT;
                    return Serializer.Serialize(resultObject);
                }

                //Check multiple account by an customer
                if (IsMultiAccount(string.Empty, accountNo))
                {
                    resultObject.RetCode = CommonEnums.RET_CODE.NOT_LOGIN;
                    return Serializer.Serialize(resultObject);
                }

                if (!ETradeCommon.Utils.IsValidDate(strEffDate) || !ETradeCommon.Utils.IsValidDate(strExpDate))
                {
                    resultObject.RetCode = CommonEnums.RET_CODE.ERROR_INVALID_DATETIME;
                    return Serializer.Serialize(resultObject);
                }

                string sessionPin = Session[CommonEnums.SESSION_KEY.PIN.ToString()].ToString();

                // Validate pin
                if (PasswordHandlerMd5.Encrypt(pin) != sessionPin)
                {
                    resultObject.RetCode = CommonEnums.RET_CODE.INCORRECT_PIN;
                    return Serializer.Serialize(resultObject);
                }

                // Check permission
                var subCustAccount = (SubCustAccount)Session[accountNo + CommonEnums.SESSION_KEY.TRADING_ACCOUNT];
                var permissionList = subCustAccount.SubCustAccountPermissionCollection;
                bool isAllow = false;
                if (permissionList != null)
                {
                    foreach (var subCustAccountPermission in permissionList)
                    {
                        if (subCustAccountPermission.CustServicesPermissionId == (int)CommonEnums.SUB_ACCOUNT_PERMISSIONS.CONDITION_ORDER)
                        {
                            isAllow = true;
                            break;
                        }
                    }
                }
                if (!isAllow)
                {
                    resultObject.RetCode = CommonEnums.RET_CODE.NOT_ALLOW;
                    return Serializer.Serialize(resultObject);
                }
                char conPrice = Constants.ORDER_TYPE_LO;
                if (type == (short)CommonEnums.CONDITION_ORDER_TYPE.ATO)
                {
                    conPrice = Constants.ORDER_TYPE_ATO;
                    price = -1;
                }
                else if (type == (short)CommonEnums.CONDITION_ORDER_TYPE.MP)
                {
                    resultObject.RetCode = CommonEnums.RET_CODE.FAIL;
                    return Serializer.Serialize(resultObject);
                }
                int accountType = ETradeCommon.Utils.GetAccountType(accountNo);
                int customerType = int.TryParse(Session[CommonEnums.SESSION_KEY.CUSTOMER_TYPE.ToString()].ToString(),
                                                out customerType)
                                       ? customerType
                                       : (int)CommonEnums.CUSTOMER_TYPE.INTERNAL;
                bool isMargin = false;
                if (side == (char)CommonEnums.TRADE_SIDE.BUY)
                {
                    if (ETradeCommon.Utils.GetAccountType(accountNo) == (int)CommonEnums.ACCOUNT_TYPE.MARGIN)
                    {
                        isMargin = true;
                        CommonEnums.REJECT_REASON isValidBuyMarginAccount = ValidateServices.IsValidBuyMarginAccount(accountNo, secSymbol, price, volume, strEffDate, true);
                        if (isValidBuyMarginAccount != CommonEnums.REJECT_REASON.IS_VALID)
                        {
                            resultObject.RetCode = CommonEnums.RET_CODE.FAIL;
                            resultObject.Result = (int)isValidBuyMarginAccount;
                            return Serializer.Serialize(resultObject);
                        }
                    }
                }

                var rejectCode = ValidateServices.IsValidAdvanceOrder(market, accountNo, secSymbol, side, volume, price,
                                                                      conPrice, accountType, customerType,
                                                                      subCustAccount, isMargin, strEffDate);
                // Putting advance orders
                if (rejectCode == CommonEnums.REJECT_REASON.IS_VALID)
                {
                    var conditionOrder = new ConditionOrder
                    {
                        SecSymbol = secSymbol,
                        Side = side.ToString(),
                        Price = price,
                        Volume = volume,
                        MatchedVolume = 0,
                        SubCustAccountId = accountNo,
                        MainCustAccountId = (string)Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()],
                        Market = market.ToString(),
                        TypeOfCond = type,
                        MinValue = minValue,
                        MaxValue = maxValue,
                        Status = ((int)CommonEnums.CONDITION_ORDER_STATUS.WAITING).ToString(),
                        TradeTime = DateTime.Now
                    };
                    if (!string.IsNullOrEmpty(strEffDate))
                    {
                        var effDate = DateTime.ParseExact(strEffDate, "yyyyMMdd", null);
                        conditionOrder.EffDate = effDate;
                    }
                    if (!string.IsNullOrEmpty(strExpDate))
                    {
                        var expDate = DateTime.ParseExact(strExpDate, "yyyyMMdd", null);
                        conditionOrder.ExpDate = expDate;
                    }

                    var conditionOrderService = new ConditionOrderService();
                    bool result = conditionOrderService.Insert(conditionOrder);
                    if (result)
                    {
                        resultObject.RetCode = CommonEnums.RET_CODE.SUCCESS;
                    }
                }
                else
                {
                    resultObject.RetCode = CommonEnums.RET_CODE.FAIL;
                    resultObject.Result = (int)rejectCode;
                }

            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                resultObject.RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR;
                resultObject.ErrorMessage = e.Message;
            }
            return Serializer.Serialize(resultObject);
        }

        /// <summary>
        /// Cancel advance orders.
        /// </summary>
        /// <param name="conditionOrderId">Condition Order Id</param>
        /// <param name="subCustAccountId">Sub account Id</param>
        /// <param name="pin">Pin</param>
        /// <returns>
        /// <para>Result of cancelling advance order.</para>
        /// <para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// <para>RET_CODE=ERROR_ACCOUNT: Information of account in session does not exist.</para>
        /// <para>RET_CODE=INCORRECT_PIN: The pin is incorrect.</para>
        /// <para>RET_CODE=ADVANCE_ORDER_STATUS_INCORRECT_STATE: The order is not in the correct state to cancel.</para>
        /// <para>RET_CODE=NO_EXISTED_DATA: Data does not exist.</para>
        /// <para>RET_CODE=SUCCESS: Cancel successfully.</para>
        /// <para>RET_CODE=FAIL: Fail to cancel order.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Cancel advance orders", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string CancelAdvanceOrder(long conditionOrderId, string subCustAccountId, string pin,string apiKey)
        {
            var resultObject = new ResultObject<int>();
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    resultObject.RetCode = CommonEnums.RET_CODE.NOT_LOGIN;
                    return Serializer.Serialize(resultObject);
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                        });
                }
                if (Session[subCustAccountId + CommonEnums.SESSION_KEY.TRADING_ACCOUNT] == null)
                {
                    resultObject.RetCode = CommonEnums.RET_CODE.ERROR_ACCOUNT;
                    return Serializer.Serialize(resultObject);
                }

                //Check multiple account by an customer
                if (IsMultiAccount(string.Empty, subCustAccountId))
                {
                    resultObject.RetCode = CommonEnums.RET_CODE.NOT_LOGIN;
                    return Serializer.Serialize(resultObject);
                }

                string sessionPin = Session[CommonEnums.SESSION_KEY.PIN.ToString()].ToString();

                // Validate pin
                if (PasswordHandlerMd5.Encrypt(pin) != sessionPin)
                {
                    resultObject.RetCode = CommonEnums.RET_CODE.INCORRECT_PIN;
                    return Serializer.Serialize(resultObject);
                }

                var result = ConditionOrderService.CancelConditionOrder(conditionOrderId, subCustAccountId);
                resultObject.RetCode = result;
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                resultObject.RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR;
                resultObject.ErrorMessage = e.Message;
            }
            return Serializer.Serialize(resultObject);
        }

        /// <summary>
        /// Put orders of condition orders at the beginning of trading days
        /// </summary>
        /// <returns>
        /// <para>Result of putting condition orders.</para>
        /// </returns>
        [WebMethod(Description = "Put advance orders at the beginning of day")]
        public int PutConditionOrder(string apiKey)
        {
            if (string.IsNullOrEmpty(apiKey) || Session==null||Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
            {
                return (int)CommonEnums.RET_CODE.INVAILID_API_KEY;
                          
            }
            LogHandler.Log("Start putting condition orders", "PutConditionOrder", TraceEventType.Information);
            if (ETradeCommon.Utils.IsWorkingDay(DateTime.Now, SysConfig.Holidays, SysConfig.WorkingDays))
            {
                ETradeServices.StartPutConditionOrderThread();
            }
            return 0;
        }

        /// <summary>
        /// Get list of condition orders. 
        /// </summary>
        /// <param name="subAccountId">Sub account id</param>
        /// <param name="side">Buy or Sell side</param>
        /// <param name="symbol">Stock symbol</param>
        /// <param name="status">Status of orders</param>
        /// <param name="fromDate">Searched effective date from</param>
        /// <param name="toDate">Searched effective date to</param>
        /// <param name="pageIndex">Page index</param>
        /// <param name="pageSize">Page size</param>
        /// <param name="fromTool"></param>
        /// <returns>
        /// <para>A <see cref="ResultObject{T}">ResultObject&lt;PagingObject&lt;List&lt;ConditionOrder&gt;&gt;&gt;</see> object contains returned code, returned message and 
        /// list of ConditionOrder objects that contains condition order information.</para>
        /// <para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// <para>RET_CODE=ERROR_INVALID_DATETIME: The sent date is invalid.</para>
        /// <para>RET_CODE=SUCCESS: Get data successfully.</para>
        /// <para>RET_CODE=NO_EXISTED_DATA: There is no data.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Get list of condition orders")]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string GetListConditionOrder(string subAccountId, string side, string symbol, int[] status,
            string fromDate, string toDate, int pageIndex, int pageSize, int fromTool,string apiKey)
        {
            if (string.IsNullOrEmpty(apiKey) ||Session==null|| Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
            {
                return
                Serializer.Serialize(
                new ResultObject<CommonEnums.RET_CODE>
                {
                    Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                    RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                    ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                    });
                }
            var resultObject = new ResultObject<PagingObject<List<ConditionOrder>>> { Result = null };
            try
            {
                if (!string.IsNullOrEmpty(toDate))
                {
                    var tmpValue = DateTime.ParseExact(toDate, "yyyyMMdd", null);
                    tmpValue = tmpValue.AddDays(1);
                    toDate = tmpValue.ToString("yyyyMMdd");
                }

                int count;
                var list = ConditionOrderService.GetListConditionOrder(subAccountId, side, symbol, status, fromDate,
                                                                       toDate, pageIndex, pageSize, out count, fromTool);
                if (list != null && list.Count > 0)
                {
                    var pagingObject = new PagingObject<List<ConditionOrder>> { Count = count, Data = list };

                    resultObject.Result = pagingObject;
                    resultObject.RetCode = CommonEnums.RET_CODE.SUCCESS;
                }
                else
                {
                    resultObject.RetCode = CommonEnums.RET_CODE.NO_EXISTED_DATA;
                }
                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                resultObject.RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR;
                return Serializer.Serialize(resultObject);
            }
        }

        /*[WebMethod(Description = "Get list of condition orders", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string TestGetListConditionOrder(string accountNo, string side, string symbol,
            string fromTradedDate, string toTradedDate, string fromEffDate, string toEffDate, string fromEndDate,
            string toEndDate, int pageIndex, int pageSize)
        {
            return GetListConditionOrder(accountNo, side, symbol, new int[] {0, 1}, fromTradedDate, toTradedDate,
                                         fromEffDate, toEffDate, fromEndDate, toEndDate, 1, 10);
        }*/

        /// <summary>
        /// Get list of condition order details. 
        /// </summary>
        /// <param name="conditionOrderId">Condition order Id</param>
        /// <returns>
        /// <para>A <see cref="ResultObject{T}">ResultObject&lt;List&lt;ConditionOrderDetail&gt;&gt</see> object contains returned code, returned message and 
        /// list of ConditionOrderDetail objects that contains condition order detail information.</para>
        /// <para>RET_CODE=NOT_LOGIN: User has not loged in or multiple login.</para>
        /// <para>RET_CODE=SUCCESS: Get data successfully.</para>
        /// <para>RET_CODE=NO_EXISTED_DATA: There is no data.</para>
        /// <para>RET_CODE=SYSTEM_ERROR: System error.</para>
        /// </returns>
        [WebMethod(Description = "Get order history", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string GetListConditionOrderDetail(long conditionOrderId,string apiKey)
        {
            var resultObject = new ResultObject<List<ConditionOrderDetail>> { Result = null };
            try
            {
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    resultObject.RetCode = CommonEnums.RET_CODE.NOT_LOGIN;
                    return Serializer.Serialize(resultObject);
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                        });
                }
                var list = ConditionOrderDetailService.GetByConditionOrderId(conditionOrderId);
                if (list != null && list.Count > 0)
                {
                    var returnList = list.ToList();
                    resultObject.Result = returnList;
                    resultObject.RetCode = CommonEnums.RET_CODE.SUCCESS;
                }
                else
                {
                    resultObject.RetCode = CommonEnums.RET_CODE.NO_EXISTED_DATA;
                }
                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                resultObject.RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR;
                return Serializer.Serialize(resultObject);
            }
        }

        /// <summary>
        /// Update expire condition orders and rejected condition orders.
        /// </summary>
        /// <returns>
        /// <para>Result of reseting condition orders.</para>
        /// </returns>
        [WebMethod(Description = "Update expire condition orders and rejected condition orders.")]
        public int ResetConditionOrder(string apiKey)
        {
            if (string.IsNullOrEmpty(apiKey) || Session==null||Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
            {
                return (int)CommonEnums.RET_CODE.INVAILID_API_KEY;                            
            }
            try
            {
                LogHandler.Log("Start Reseting condition orders", "ResetConditionOrder", TraceEventType.Information);
                ConditionOrderService.UpdateExpiredData(1);
                return (int)CommonEnums.RET_CODE.SUCCESS;
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                return (int)CommonEnums.RET_CODE.SYSTEM_ERROR;
            }
        }

        /// <summary>
        /// Check is valid limit quantity advance order if not enough cash available
        /// </summary>
        /// <param name="side">The side.</param>
        /// <param name="subCustAccountId">The sub cust account id.</param>
        /// <param name="symbol">The symbol.</param>
        /// <returns>
        /// 	<c>true</c> if [is valid limit quantity advance order] [the specified side]; otherwise, <c>false</c>.
        /// </returns>
        [WebMethod(Description = "Count unfinished condition order", EnableSession = true)]
        [ScriptMethod(ResponseFormat = ResponseFormat.Json)]
        public string IsValidLimitQuantityAdvanceOrder(char side, string subCustAccountId, string symbol,string apiKey)
        {
            var resultObject = new ResultObject<bool>();
            try
            {
                resultObject.Result = false;
                if (Session == null || Session[CommonEnums.SESSION_KEY.CUSTOMER_ACCOUNT.ToString()] == null)
                {
                    resultObject.RetCode = CommonEnums.RET_CODE.NOT_LOGIN;
                    return Serializer.Serialize(resultObject);
                }
                else if (string.IsNullOrEmpty(apiKey) || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()] == null || Session[CommonEnums.SESSION_KEY.API_KEY.ToString()].ToString().CompareTo(apiKey) != 0)
                {
                    return
                    Serializer.Serialize(
                        new ResultObject<CommonEnums.RET_CODE>
                        {
                            Result = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            RetCode = CommonEnums.RET_CODE.INVAILID_API_KEY,
                            ErrorMessage = CommonEnums.RET_CODE.INVAILID_API_KEY.ToString()
                        });
                }
                resultObject.Result = ValidateServices.IsValidLimitQuantityAdvanceOrder(side, subCustAccountId, symbol);
                resultObject.RetCode = CommonEnums.RET_CODE.SUCCESS;
                return Serializer.Serialize(resultObject);
            }
            catch (Exception e)
            {
                ExceptionHandler.HandleException(e, WEB_SERVICE_POLICY);
                resultObject.RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR;
                return Serializer.Serialize(resultObject);
            }
        }
        #endregion order
    }
}
