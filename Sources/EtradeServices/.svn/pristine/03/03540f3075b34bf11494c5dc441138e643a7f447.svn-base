// --------------------------------------------------------------------------------------------------------------------
// <copyright file="ETradeServices.cs" company="OTS">
//   2010
// </copyright>
// <summary>
//   This is main service and used to call other services
// </summary>
// --------------------------------------------------------------------------------------------------------------------

using System.Configuration;
using System.Data;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Resources;
using System.Text;
using System.Threading;
using System.Web.Script.Serialization;
using AccountManager.Entities;
using ETradeCommon;
using ETradeCommon.Enums;
using ETradeCore.Entities;
using ETradeCore.Services;
using ETradeFinance.Entities;
using ETradeFinance.Services;
using ETradeOrders.Entities;
using ETradeOrders.Services;
using ETradeWebServices.AMServices;
using ETradeWebServices.RTServices;
using ETradeWebServices.Utils;
using RTDataServices.Entities;
using CashAdvance = ETradeCore.Entities.CashAdvance;
using ETradeCommon;
using System.Web;
using System.Linq;
namespace ETradeWebServices.Services
{
    /// <summary>
    /// This is main service and used to call other services
    /// </summary>
    public class ETradeServices
    {
        /// <summary>
        /// The cash services: related all cash informations
        /// </summary>
        private readonly CashServices _cashServices = new CashServices();

        /// <summary>
        /// eTradeGW: related orders
        /// </summary>
        private readonly ETradeGWServices.ETradeGW _eTradeGW = new ETradeGWServices.ETradeGW();

        private readonly ExecOrderService _execOrderService = new ExecOrderService();

        /// <summary>
        /// The stock services: related all stock informations
        /// </summary>
        private readonly StockServices _stockServices = new StockServices();

        /// <summary>
        /// The order history services: related all order history informations
        /// </summary>
        private readonly OrderHistoryServices _orderHistoryServices = new OrderHistoryServices();

        private readonly DealServices _dealServices = new DealServices();

        private readonly ValidateServices _validateServices = new ValidateServices();

        private readonly Service _rtServices = new Service();

        private static readonly JavaScriptSerializer Serializer = new JavaScriptSerializer();

        private readonly CashAdvanceServices _cashAdvanceServices = new CashAdvanceServices();

        private readonly ActualTradeServices _actualTradeServices = new ActualTradeServices();

        private readonly ConditionOrderService _conditionOrderService = new ConditionOrderService();

        private readonly ConditionOrderDetailService _conditionOrderDetailService = new ConditionOrderDetailService();

        private readonly AccountManagerServices _accountManagerServices = new AccountManagerServices();

        private readonly BankServices _bankServices = new BankServices();

        private readonly  MarginServices _marginServices=new MarginServices();

        private readonly CashTransferService _cashTransferService=new CashTransferService();

        private readonly StockTransferService _stockTransferService=new StockTransferService();

        private readonly XrOrdersService _xrOrdersService=new XrOrdersService();

        private readonly OddLotOrderService _oddLotOrderService=new OddLotOrderService();

        private static bool _conditionOrderThreadRun = false;
        /// <summary>
        /// Recovery lost packages from begin sequence to end sequence.
        /// </summary>
        /// <param name="beginSeq">Begin Sequence.</param>
        /// <param name="endSeq">End Sequence.</param>
        /// <returns>ResultObject&lt;Boolean&gt;</returns>
        public ResultObject<Boolean> Recovery(int beginSeq, int endSeq)
        {
            Boolean ret = _eTradeGW.Recovery(beginSeq, endSeq);

            return new ResultObject<Boolean>
            {
                ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString(),
                Result = ret,
                RetCode = CommonEnums.RET_CODE.SUCCESS
            };
        }

        #region Cash
        /// <summary>
        /// Gets the available cash.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <param name="accountType">Type of the account.</param>
        /// <returns>CashAvailable</returns>
        public ResultObject<CashAvailable> GetAvailableCash(string accountNo, int accountType)
        {
            CashAvailable cashAvailable = _cashServices.GetAvailableCash(accountNo, accountType);

            if (cashAvailable == null)
            {
                return new ResultObject<CashAvailable>
                {
                    Result = null,
                    ErrorMessage = CommonEnums.RET_CODE.ERROR_NOT_CASH_AVAILABLE.ToString(),
                    RetCode = CommonEnums.RET_CODE.ERROR_NOT_CASH_AVAILABLE
                };
            }
            /*
              CashTransferService cashTransferService = new CashTransferService();
             //total cash transfered amount in status pending & processing 
             cashAvailable.CashTransferedAmount = cashTransferService.GetTotalUnfinishedCashTransferAmount(accountNo);
             //total advance ordered amount in status pending & processing
             cashAvailable.AdvanceOrderedAmount = _validateServices.GetTotalConditionOrderMoney((char)CommonEnums.TRADE_SIDE.BUY, accountNo, -1);
             cashAvailable.BuyCredit = cashAvailable.BuyCredit - (cashAvailable.CashTransferedAmount + cashAvailable.AdvanceOrderedAmount);           
             */

            return new ResultObject<CashAvailable>
            {
                ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString(),
                Result = cashAvailable,
                RetCode = CommonEnums.RET_CODE.SUCCESS
            };
        }

        /// <summary>
        /// Gets the cash balance.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <param name="accountType">Type of the account.</param>
        /// <returns>CashBalance</returns>
        public ResultObject<CashBalance> GetCashBalance(string accountNo, int accountType)
        {
            CashBalance cashBalance = _cashServices.GetCashBalance(accountNo, accountType);

            if (cashBalance == null)
                return new ResultObject<CashBalance>
                {
                    ErrorMessage = CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                    Result = null,
                    RetCode = CommonEnums.RET_CODE.NO_EXISTED_DATA
                };
            /* 
            CashTransferService cashTransferService=new CashTransferService();
            //total cash transfered amount in status pending & processing 
            cashBalance.CashTransferedAmount = cashTransferService.GetTotalUnfinishedCashTransferAmount(accountNo);           
            //total advance ordered amount in status pending & processing
            cashBalance.AdvanceOrderedAmount =_validateServices.GetTotalConditionOrderMoney((char) CommonEnums.TRADE_SIDE.BUY, accountNo, -1);
            cashBalance.BuyCredit = cashBalance.BuyCredit - (cashBalance.CashTransferedAmount + cashBalance.AdvanceOrderedAmount);           
            */


            return new ResultObject<CashBalance>
            {
                ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString(),
                Result = cashBalance,
                RetCode = CommonEnums.RET_CODE.SUCCESS
            };
        }
        #endregion      

        #region Stock
        /// <summary>
        /// Gets the stock balance.
        /// </summary>
        /// <param name="accountNo">
        /// The account no.
        /// </param>
        /// <param name="symbol">
        /// The symbol.
        /// </param>
        /// <param name="accountType">
        /// The account Type.
        /// </param>
        /// <returns>
        /// </returns>
        public ResultObject<StockAvailable> GetAvailableStock(string accountNo, string symbol, int accountType)
        {
            StockAvailable stockBalance = _stockServices.GetStockAvailable(accountNo, symbol, accountType);

            if (stockBalance == null)
                return new ResultObject<StockAvailable>
                {
                    ErrorMessage = CommonEnums.RET_CODE.ERROR_NOT_STOCK_AVAILABLE.ToString(),
                    Result = null,
                    RetCode = CommonEnums.RET_CODE.ERROR_NOT_STOCK_AVAILABLE
                };
            /*
                        stockBalance.SecSymbol = symbol;
                        StockTransferService stockTransferService=new StockTransferService();
                        //total stock transfered amount in status pending & processing 
                        stockBalance.StockTransferedAmount = stockTransferService.GetTotalUnfinishedStockTransferAmount(accountNo,symbol);
                        //total advance ordered amount in status pending & processing
                        stockBalance.AdvanceOrderedAmount =_validateServices.GetTotalConditionOrderStock((char) CommonEnums.TRADE_SIDE.SELL, accountNo, -1, symbol);
                        stockBalance.AvaiVolume = stockBalance.AvaiVolume -(stockBalance.StockTransferedAmount + stockBalance.AdvanceOrderedAmount);
             */

            return new ResultObject<StockAvailable>
            {
                Result = stockBalance,
                RetCode = CommonEnums.RET_CODE.SUCCESS,
                ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString()
            };
        }
        #endregion
        
        #region Order
        /// <summary>
        /// Gets the order history.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <param name="fromDate">From date.</param>
        /// <param name="toDate">To date.</param>
        /// <param name="symbol">The symbol.</param>
        /// <param name="orderStatus">The order status.</param>
        /// <param name="pageNumber">The page number.</param>
        /// <param name="pageSize">Size of the page.</param>
        /// <returns></returns>
        public ResultObject<PagingObject<List<OrderHistory>>> GetOrderHistory(string accountNo, string fromDate, string toDate, string symbol, int orderStatus, int pageNumber, int pageSize)
        {
            List<OrderHistory> list = _orderHistoryServices.GetOrderHistory(accountNo, fromDate, toDate, symbol, orderStatus, pageNumber, pageSize);

            if (list == null)
                return new ResultObject<PagingObject<List<OrderHistory>>>
                {
                    ErrorMessage = CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                    Result = null,
                    RetCode = CommonEnums.RET_CODE.NO_EXISTED_DATA
                };

            // Paging order history
            int startIndex;
            int count;
            if (pageNumber == 0)
            {
                startIndex = 0;
                count = list.Count;
            }
            else
            {
                startIndex = (pageNumber - 1) * pageSize;
                int remainsItemCount = list.Count - startIndex;
                count = (remainsItemCount > pageSize) ? pageSize : remainsItemCount;
            }

            var returnValue = list.GetRange(startIndex, count);

            return new ResultObject<PagingObject<List<OrderHistory>>>
            {
                ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString(),
                Result = new PagingObject<List<OrderHistory>>
                {
                    Count = list.Count,
                    Data = returnValue
                },
                RetCode = CommonEnums.RET_CODE.SUCCESS
            };
        }

        /// <summary>
        /// Gets the order history count.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <param name="fromDate">From date.</param>
        /// <param name="toDate">To date.</param>
        /// <param name="symbol">The symbol.</param>
        /// <param name="orderStatus">The order status.</param>
        /// <returns></returns>
        public ResultObject<int> GetOrderHistoryCount(string accountNo, string fromDate, string toDate, string symbol, int orderStatus)
        {
            List<OrderHistory> list = _orderHistoryServices.GetOrderHistory(accountNo, fromDate, toDate, symbol, orderStatus, 0, 10);

            if (list == null)
                return new ResultObject<int>
                {
                    ErrorMessage = CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                    Result = 0,
                    RetCode = CommonEnums.RET_CODE.NO_EXISTED_DATA
                };

            return new ResultObject<int>
            {
                ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString(),
                Result = list.Count,
                RetCode = CommonEnums.RET_CODE.SUCCESS
            };
        }
        /// <summary>
        /// Puts the order.
        /// </summary>
        /// <param name="market">The market.</param>
        /// <param name="accountNo">The account no.</param>
        /// <param name="secSymbol">The sec symbol.</param>
        /// <param name="side">The side.</param>
        /// <param name="volume">The volume.</param>
        /// <param name="price">The price.</param>
        /// <param name="conPrice">The con price.</param>
        /// <param name="accountType">Type of the account.</param>
        /// <param name="customerType">Type of the customer.</param>
        /// <param name="subCustAccount">The sub cust account.</param>
        /// <param name="subCustAccounts">The sub cust accounts.</param>
        /// <returns></returns>
        public ResultObject<int> PutOrder(
            int market,
            string accountNo,
            string secSymbol,
            char side,
            int volume,
            decimal price,
            char conPrice,
            int accountType,
            int customerType,
            SubCustAccount subCustAccount,
            List<string> subCustAccounts)
        {
            var resultObject = new ResultObject<int> { RetCode = CommonEnums.RET_CODE.FAIL, Result = -1 };

            var stockAvailable = new StockAvailable();

            decimal avgPrice = 0;
            bool isMargin = false;

            try
            {
                if (side == (char)CommonEnums.TRADE_SIDE.SELL)
                {
                    stockAvailable = _stockServices.GetStockAvailable(accountNo, secSymbol, accountType);
                    avgPrice = stockAvailable != null ? stockAvailable.AvgPrice : 0;
                }
                else
                {
                    if (side == (char)CommonEnums.TRADE_SIDE.BUY)
                    {
                         if(ETradeCommon.Utils.GetAccountType(accountNo) ==(int)ETradeCommon.Enums.CommonEnums.ACCOUNT_TYPE.MARGIN)
                         {
                            isMargin = true;
                            CommonEnums.REJECT_REASON isValidBuyMarginAccount =_validateServices.IsValidBuyMarginAccount(accountNo, secSymbol, avgPrice, volume);
                            if(isValidBuyMarginAccount!=CommonEnums.REJECT_REASON.IS_VALID)
                            {
                                return new ResultObject<int>
                                {
                                    ErrorMessage = isValidBuyMarginAccount.ToString(),
                                    Result = (int)isValidBuyMarginAccount,
                                    RetCode = CommonEnums.RET_CODE.FAIL
                                };
                            }
                         }                        
                    }
                    else
                    {
                        return new ResultObject<int>
                        {
                            ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString(),
                            Result = (int)CommonEnums.RET_CODE.SYSTEM_ERROR,
                            RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR
                        };
                    }
                }
                CommonEnums.REJECT_REASON rejectReason = _validateServices.IsValidNewOrder(
                        market, accountNo, secSymbol, side, volume, price, conPrice, accountType, customerType,
                        subCustAccount, subCustAccounts, stockAvailable, -1, isMargin);

                    if (rejectReason != CommonEnums.REJECT_REASON.IS_VALID)
                    {
                        return new ResultObject<int>
                                   {
                                       ErrorMessage = rejectReason.ToString(),
                                       Result = (int) rejectReason,
                                       RetCode = CommonEnums.RET_CODE.FAIL
                                   };
                    }

                    var orderSession = MarketServices.GetOrderSession(market);
                    int orderID;
                    ExecOrder execOrder;
                    CommonEnums.RET_CODE ret = _eTradeGW.PutOrder(market, orderSession, accountNo, secSymbol, side,
                                                                  volume,
                                                                  price, conPrice, avgPrice, null, out orderID, out execOrder);

                    resultObject.Result = orderID;
                    resultObject.RetCode = ret;
                    resultObject.ErrorMessage = ret.ToString();

                    return resultObject;
                
            }
            catch (Exception exception)
            {
                LogHandler.Log("PutOrder Account = " + accountNo + " side = " + side + " Symbol = " + secSymbol + " price = " + price + " Exception = " + exception,
                     GetType() + ".PutOrder()",
                                         TraceEventType.Error);

                return new ResultObject<int>
                {
                    ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString(),
                    Result = (int)CommonEnums.RET_CODE.SYSTEM_ERROR,
                    RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR
                };
            }
        }

        ///<summary>
        ///</summary>
        public void StartPutConditionOrderThread()
        {
            // Start a new thread for putting condition orders at the beginning of the trading days.
            try
            {
                if (!_conditionOrderThreadRun)
                {
                    _conditionOrderThreadRun = true;
                    var hoseConditionOrderThread = new Thread(PutHOSEConditionOrder) { IsBackground = true };
                    var hnxConditionOrderThread = new Thread(PutHNXConditionOrder) { IsBackground = true };
                    var upcomConditionOrderThread = new Thread(PutUPCOMConditionOrder) { IsBackground = true };
                    hoseConditionOrderThread.Start();
                    hnxConditionOrderThread.Start();
                    upcomConditionOrderThread.Start();
                }
            }
            catch (Exception exception)
            {
                ExceptionHandler.HandleException(exception, Constants.EXCEPTION_POLICY);
            }
            _conditionOrderThreadRun = false;
        }
        /// <summary>
        /// Put condition orders for hose market
        /// </summary>
        public void PutHOSEConditionOrder()
        {
            PutConditionOrder((int)CommonEnums.MARKET_ID.HOSE);
        }

        /// <summary>
        /// Put condition orders for hnx market
        /// </summary>
        public void PutHNXConditionOrder()
        {
            PutConditionOrder((int)CommonEnums.MARKET_ID.HNX);
        }

        /// <summary>
        /// Put condition orders for upcom market
        /// </summary>
        public void PutUPCOMConditionOrder()
        {
            PutConditionOrder((int)CommonEnums.MARKET_ID.UPCoM);
        }

        /// <summary>
        /// Put condition order at the beginning of trading day
        /// </summary>
        public void PutConditionOrder(int marketId)
        {
            try
            {
                int checkTradingStateTime = int.Parse(ConfigurationManager.AppSettings["CheckTradingStateTime"]);
                //Check Session S of market status
                var tradingState = GetTradingState(marketId);
                // Loop until market is ready
                while (tradingState != (char)CommonEnums.MARKET_STATUS.READY)
                {
                    if ((tradingState != (char)CommonEnums.MARKET_STATUS.INIT_APP)
                        && (tradingState != (char)CommonEnums.MARKET_STATUS.UNVAILABLE)
                        && (tradingState != (char)CommonEnums.MARKET_STATUS.WAITING))
                    {
                        return;
                    }
                    Thread.Sleep(checkTradingStateTime);
                    tradingState = GetTradingState(marketId);
                }

                var todayOrderList = _conditionOrderService.GetListTodayOrders(marketId.ToString());
                bool isMargin = false;
                foreach (var todayOrder in todayOrderList)
                {
                    // Validate condition order
                    var stockAvailable = new StockAvailable();
                    decimal avgPrice = 0;
                    MainCustAccount mainCustAccount = null;
                    try
                    {

                        var conditionOrderId = todayOrder.ConditionOrderId;
                        var secSymbol = todayOrder.SecSymbol;
                        var side = (todayOrder.Side)[0];
                        var price = todayOrder.Price;

                        var mainVolume = todayOrder.Volume;
                        var matchedVolume = todayOrder.MatchedVolume;
                        var volume = mainVolume - matchedVolume;//Remaining volume to put order

                        var subCustAccountId = todayOrder.SubCustAccountId;
                        var mainCustAccountId = todayOrder.MainCustAccountId;
                        var market = int.Parse(todayOrder.Market);
                        int accountType = ETradeCommon.Utils.GetAccountType(subCustAccountId);
                        var typeOfOrder = todayOrder.TypeOfCond;
                        int customerType = (int)CommonEnums.CUSTOMER_TYPE.INTERNAL;

                        char conPrice = Constants.ORDER_TYPE_LO;
                        if (typeOfOrder == (short)CommonEnums.CONDITION_ORDER_TYPE.ATO)
                        {
                            conPrice = Constants.ORDER_TYPE_ATO;
                        }
                        else if (typeOfOrder == (short)CommonEnums.CONDITION_ORDER_TYPE.ATC)
                        {
                            conPrice = Constants.ORDER_TYPE_ATC;
                        }

                        if (side == (char)CommonEnums.TRADE_SIDE.SELL)
                        {
                            stockAvailable = _stockServices.GetStockAvailable(subCustAccountId, secSymbol, accountType);

                            avgPrice = stockAvailable != null ? stockAvailable.AvgPrice : 0;
                        }
                        else
                        {
                            if (side == (char)CommonEnums.TRADE_SIDE.BUY)
                            {
                                if (ETradeCommon.Utils.GetAccountType(subCustAccountId) == (int)ETradeCommon.Enums.CommonEnums.ACCOUNT_TYPE.MARGIN)
                                {
                                    isMargin = true;
                                    CommonEnums.REJECT_REASON isValidBuyMarginAccount = _validateServices.IsValidBuyMarginAccount(subCustAccountId, secSymbol, avgPrice, volume);
                                    if (isValidBuyMarginAccount != CommonEnums.REJECT_REASON.IS_VALID)
                                    {
                                        // Send failure message
                                        SendSMSMessageConditionOrder(mainCustAccount.MainCustAccountId, CommonEnums.REJECT_REASON.NOTHING,
                                                                 market, secSymbol, volume, price, side);
                                    }
                                }
                            }                            
                        }

                        // Get sub customer account information
                        var subCustAccountIdList = new List<string>();
                        SubCustAccount subCustAccount = null;
                        var strMainCustAccount = _accountManagerServices.GetCustomerNoSession(mainCustAccountId);
                        var mainResultObject = Serializer.Deserialize<ResultObject<MainCustAccount>>(strMainCustAccount);
                        mainCustAccount = mainResultObject.Result;
                        if (mainCustAccount != null)
                        {
                            customerType = mainCustAccount.CustomerType;
                            var subCustAccounts = mainCustAccount.SubCustAccountCollection;
                            if (subCustAccounts != null)
                            {
                                foreach (var tmp in subCustAccounts)
                                {
                                    subCustAccountIdList.Add(tmp.SubCustAccountId);
                                    if (tmp.SubCustAccountId == subCustAccountId)
                                    {
                                        subCustAccount = tmp;
                                    }
                                }
                            }
                        }

                        CommonEnums.REJECT_REASON rejectReason = _validateServices.IsValidNewOrder(
                                   market, subCustAccountId, secSymbol, side, volume, price, conPrice, accountType,
                                   customerType, subCustAccount, subCustAccountIdList, stockAvailable, conditionOrderId, 
                                   isMargin);

                        if (rejectReason == CommonEnums.REJECT_REASON.IS_VALID)
                        {
                            var orderSession = MarketServices.GetOrderSession(market);
                            int orderID;

                            ExecOrder execOrder;
                            CommonEnums.RET_CODE ret = _eTradeGW.PutOrder(market, orderSession, subCustAccountId, secSymbol, side,
                                                                          volume, price, conPrice, avgPrice, conditionOrderId, out orderID, out execOrder);
                            if (ret == CommonEnums.RET_CODE.SUCCESS)
                            {
                                //Send success sms message
                                SendSMSMessageConditionOrder(mainCustAccount.MainCustAccountId, CommonEnums.REJECT_REASON.IS_VALID,
                                                         market, secSymbol, volume, price, side);

                                // Update condition order status
                                _conditionOrderService.UpdateConditionOrderStatus(conditionOrderId,
                                                                                  ((int)CommonEnums.CONDITION_ORDER_STATUS.ACTIVED).ToString());
                            }
                            // Insert condition order detail
                            var conditionOrderDetail = new ConditionOrderDetail
                            {
                                ConditionOrderId = conditionOrderId,
                                Volume = mainVolume,
                                MatchedVolume = matchedVolume,
                                OrderStatus = execOrder.OrderStatus,
                                CreatedDateTime = DateTime.Now,
                                FisOrderId = execOrder.FisOrderId,
                                NumOfMatch = execOrder.NumOfMatch,
                                CancelledVol = execOrder.CancelledVolume

                            };
                            if (ret == CommonEnums.RET_CODE.SUCCESS)
                            {
                                conditionOrderDetail.OrdRejReason = execOrder.OrdRejReason;
                            }
                            else
                            {
                                conditionOrderDetail.OrdRejReason =
                                    (int) CommonEnums.REJECT_REASON.ERROR_PUT_ORDER_FAILED;
                            }
                            var result = _conditionOrderDetailService.Insert(conditionOrderDetail);
                            if (!result)
                            {
                                LogHandler.Log(string.Format("Insert chi tiet lenh dat cua TK {0} cho CP {1}, gia {2}, KL {3} bi loi.",
                                    mainCustAccount.MainCustAccountId, secSymbol, price, volume),
                                   GetType() + ".PutConditionOrder()", TraceEventType.Error);
                            }
                        }
                        else
                        {
                            SendSMSMessageConditionOrder(mainCustAccount.MainCustAccountId, rejectReason, market, secSymbol,
                                                         volume, price, side);
                            // Insert condition order detail
                            var conditionOrderDetail = new ConditionOrderDetail
                            {
                                ConditionOrderId = conditionOrderId,
                                Volume = mainVolume,
                                MatchedVolume = matchedVolume,
                                OrderStatus = -1,
                                CreatedDateTime = DateTime.Now,
                                FisOrderId = 0,
                                OrdRejReason = (int) rejectReason,
                                NumOfMatch = 0,
                                CancelledVol = 0

                            };

                            var result = _conditionOrderDetailService.Insert(conditionOrderDetail);
                            if (!result)
                            {
                                LogHandler.Log(string.Format("Insert chi tiet lenh dat cua TK {0} cho CP {1}, gia {2}, KL {3} bi loi.",
                                    mainCustAccount.MainCustAccountId, secSymbol, price, volume),
                                   GetType() + ".PutConditionOrder()", TraceEventType.Error);
                            }
                            
                        }
                    }
                    catch (Exception exception)
                    {
                        ExceptionHandler.HandleException(exception, Constants.EXCEPTION_POLICY);
                        // Send failure message
                        if (mainCustAccount != null)
                        {
                            LogHandler.Log(string.Format("Lenh dat cua TK {0} cho CP {1}, gia {2}, KL {3} bi loi.", 
                                       mainCustAccount.MainCustAccountId, todayOrder.SecSymbol, todayOrder.Price, todayOrder.Volume),
                                       GetType() + ".PutConditionOrder()", TraceEventType.Error);
                            SendSMSMessageConditionOrder(mainCustAccount.MainCustAccountId,
                                                         CommonEnums.REJECT_REASON.NOTHING, int.Parse(todayOrder.Market),
                                                         todayOrder.SecSymbol, todayOrder.Volume, todayOrder.Price,
                                                         (todayOrder.Side)[0]);
                        }

                    }
                }
            } catch(Exception ex)
            {
                ExceptionHandler.HandleException(ex, Constants.EXCEPTION_POLICY);
            }
        }
        /// <summary>
        /// Send result of putting condition order to customers
        /// </summary>
        /// <param name="mainCustAccountId"></param>
        /// <param name="rejectReason">Reject reason or success</param>
        /// <param name="market"></param>
        /// <param name="symbol"></param>
        /// <param name="volume"></param>
        /// <param name="price"></param>
        private void SendSMSMessageConditionOrder(string mainCustAccountId, CommonEnums.REJECT_REASON rejectReason,
            int market, string symbol, int volume, decimal price, char side)
        {
            string message;
            string sideString;
            if (side == (char)CommonEnums.TRADE_SIDE.SELL)
            {
                sideString = Resources.Resource.SELL.ToUpper();
            }
            else
            {
                sideString = Resources.Resource.BUY.ToUpper();
            }

            if (rejectReason == CommonEnums.REJECT_REASON.IS_VALID)
            {
                message = string.Format(Resources.Resource.PUT_ORDER_SUCCESS, mainCustAccountId, sideString, symbol, price, volume);
            }
            else
            {
                message = string.Format(Resources.Resource.PUT_ORDER_UNSUCCESS, mainCustAccountId, sideString, symbol, price, volume);
            }
            switch (rejectReason)
            {

                case CommonEnums.REJECT_REASON.IS_VALID:
                    // Lenh dat truoc cua quy khach da duoc dat thanh cong.
                    break;
                //case CommonEnums.REJECT_REASON.MP_WITHOUT_CONTRA_SIDE:
                //case CommonEnums.REJECT_REASON.ILLEGAL_PRICE_SPREAD:
                case CommonEnums.REJECT_REASON.INCORRECT_VOL:
                    // Incorrect market volume
                    message = message + " " + string.Format(Resources.Resource.INCORRECT_VOL, volume);
                    break;
                //case CommonEnums.REJECT_REASON.MARKET_CLOSE:
                case CommonEnums.REJECT_REASON.INCORRECT_STOCK:
                    // Stock is not exist
                    message = message + " " + string.Format(Resources.Resource.INCORRECT_STOCK, symbol);
                    break;
                //case CommonEnums.REJECT_REASON.INCORRECT_FIRM:
                //case CommonEnums.REJECT_REASON.INCORRECT_TRADER_ID:
                //case CommonEnums.REJECT_REASON.INCORRECT_CONFIRM_NO:
                //case CommonEnums.REJECT_REASON.LATE_REQ_ACTION:
                //case CommonEnums.REJECT_REASON.INCORRECT_REFER_NO:
                //case CommonEnums.REJECT_REASON.INCORRECT_CONDITION:
                //case CommonEnums.REJECT_REASON.TRADING_HALT:
                //case CommonEnums.REJECT_REASON.INCORRECT_BOARD:
                //case CommonEnums.REJECT_REASON.MISSING_CLIENT_ID:
                //case CommonEnums.REJECT_REASON.INCORRECT_ORDER_TYPE:
                //case CommonEnums.REJECT_REASON.INCORRECT_FLAG:
                //case CommonEnums.REJECT_REASON.INCORRECT_CODE:
                case CommonEnums.REJECT_REASON.INCORRECT_SIDE:
                    // Must be Buy or Sell side
                    message = message + " " + Resources.Resource.INCORRECT_SIDE;
                    break;
                //case CommonEnums.REJECT_REASON.INCORRECT_ORDER_NO:
                //case CommonEnums.REJECT_REASON.INCORRECT_TIME:
                //case CommonEnums.REJECT_REASON.INCORRECT_DATE:
                //case CommonEnums.REJECT_REASON.NOT_DO_ODD_LOT_BOARD:
                //case CommonEnums.REJECT_REASON.INCORRECT_SUB_BROKER_ID:
                //case CommonEnums.REJECT_REASON.ILLEGAL_TRUSTEE_ID:
                //case CommonEnums.REJECT_REASON.SECURITY_SUSPEND:
                //case CommonEnums.REJECT_REASON.MISSING_PC_FLAG:
                //case CommonEnums.REJECT_REASON.MISSING_SUB_BROKER_ID:
                //case CommonEnums.REJECT_REASON.NO_VAILABLE_ROOM:
                //case CommonEnums.REJECT_REASON.MARKET_INTERMISSION:
                //case CommonEnums.REJECT_REASON.MARKET_HALT:
                //case CommonEnums.REJECT_REASON.INCORRECT_PUB_VOL:
                //case CommonEnums.REJECT_REASON.DISALLOW_CHANGE_DEAL:
                //case CommonEnums.REJECT_REASON.DISALLW_PUB_VOL:
                //case CommonEnums.REJECT_REASON.DISALLOW_TRADING_STOCK:
                case CommonEnums.REJECT_REASON.PRICE_ABOVE_CEILING:
                    //Price is above ceiling price
                    message = message + " " + Resources.Resource.PRICE_ABOVE_CEILING;
                    break;
                case CommonEnums.REJECT_REASON.PRICE_BELOW_FLOOR:
                    // Price is below floor price
                    message = message + " " + Resources.Resource.PRICE_BELOW_FLOOR;
                    break;
                //case CommonEnums.REJECT_REASON.PTHR_INCORRECT_FORMAT:
                //case CommonEnums.REJECT_REASON.DISALLW_CANCEL_AUTOMATCH_DEAL:
                //case CommonEnums.REJECT_REASON.PTHR_INCORRECT_VOL:
                //case CommonEnums.REJECT_REASON.INCORRECT_MARKET_MAKER:
                //case CommonEnums.REJECT_REASON.ILLEGAL_SHORT_SALES_ORDER:
                //case CommonEnums.REJECT_REASON.ILLEGAL_MARKET_ID:
                //case CommonEnums.REJECT_REASON.ILLEGAL_MARKET_TYPE:
                //case CommonEnums.REJECT_REASON.ILLEGAL_MESSAGE_LENGTH:
                //case CommonEnums.REJECT_REASON.PRICE_OVER:
                //case CommonEnums.REJECT_REASON.DISAPPROVE_ORDER:
                //case CommonEnums.REJECT_REASON.REJECT_FROM_FIS:
                //case CommonEnums.REJECT_REASON.HALTED_TRADER_ID:
                //case CommonEnums.REJECT_REASON.UNIDENTIFIED_ERROR:
                //case CommonEnums.REJECT_REASON.INCORRECT_ACCOUNT_ID:
                case CommonEnums.REJECT_REASON.NOT_ENOUGH_CASH:
                    // Not enough cash
                    message = message + " " + Resources.Resource.NOT_ENOUGH_CASH;
                    break;
                case CommonEnums.REJECT_REASON.NOT_ENOUGH_STOCK:
                    // Not enough stock
                    message = message + " " + Resources.Resource.NOT_ENOUGH_STOCK;
                    break;
                case CommonEnums.REJECT_REASON.NOT_BUY_SELL_THE_SAME_STOCK:
                    // Not allow to buy or sell the same stock
                    message = message + " " + Resources.Resource.NOT_BUY_SELL_THE_SAME_STOCK;
                    break;
                //case CommonEnums.REJECT_REASON.NOT_CANCEL_ORDER_FROM_DIFF_SOURCE:
                //case CommonEnums.REJECT_REASON.NOT_CANCEL_ATO_ATC:
                //case CommonEnums.REJECT_REASON.NOT_CANCEL_IN_THIS_PERIOD_PHASE:
                case CommonEnums.REJECT_REASON.OVER_REMAIN_VOLUME:
                    // over remain room
                    message = message + " " + Resources.Resource.OVER_REMAIN_VOLUME;
                    break;
                case CommonEnums.REJECT_REASON.STOCK_IS_HALT:
                    // Stock is halt
                    message = message + " " + string.Format(Resources.Resource.STOCK_IS_HALT, symbol);
                    break;
                case CommonEnums.REJECT_REASON.OVER_MAX_VOL:
                    // Over max volume
                    message = message + " " + Resources.Resource.OVER_MAX_VOL;
                    break;
                //case CommonEnums.REJECT_REASON.NOT_ALLOW_TRADE_BONDS:
                //case CommonEnums.REJECT_REASON.NOT_CANCEL_ORDER_CANCELED:
                case CommonEnums.REJECT_REASON.ERROR_PRICE_NOT_MULTIPLE_100_FOR_HOSE:
                    // Incorrect step price
                    message = message + " " + Resources.Resource.ERROR_PRICE_NOT_MULTIPLE_100_FOR_HOSE;
                    break;
                case CommonEnums.REJECT_REASON.ERROR_PRICE_NOT_MULTIPLE_500_FOR_HOSE:
                    // Incorrect step price
                    message = message + " " + Resources.Resource.ERROR_PRICE_NOT_MULTIPLE_500_FOR_HOSE;
                    break;
                case CommonEnums.REJECT_REASON.ERROR_PRICE_NOT_MULTIPLE_1000_FOR_HOSE:
                    // Incorrect step price
                    message = message + " " + Resources.Resource.ERROR_PRICE_NOT_MULTIPLE_1000_FOR_HOSE;
                    break;
                case CommonEnums.REJECT_REASON.ERROR_HNX_NOT_USE_ATO_ATC:
                    // No ATO or ATC for HNX
                    message = message + " " + Resources.Resource.ERROR_HNX_NOT_USE_ATO_ATC;
                    break;
                case CommonEnums.REJECT_REASON.ERROR_PRICE_NOT_MULTIPLE_100_FOR_HNX:
                    // Incorrect step price
                    message = message + " " + Resources.Resource.ERROR_PRICE_NOT_MULTIPLE_100_FOR_HNX;
                    break;
                case CommonEnums.REJECT_REASON.ERROR_LOCK_ACCOUNT:
                    // Account is locked
                    message = message + " " + Resources.Resource.ERROR_LOCK_ACCOUNT;
                    break;
                case CommonEnums.REJECT_REASON.ERROR_ACCOUNT_NOT_BUY_PERMISSION:
                    // No buy permission
                    message = message + " " + Resources.Resource.ERROR_ACCOUNT_NOT_BUY_PERMISSION;
                    break;
                case CommonEnums.REJECT_REASON.ERROR_ACCOUNT_NOT_SELL_PERMISSION:
                    // No sell permission
                    message = message + " " + Resources.Resource.ERROR_ACCOUNT_NOT_SELL_PERMISSION;
                    break;
                case CommonEnums.REJECT_REASON.ERROR_ACCOUNT_NOT_TRADE_PERMISSION:
                    // No trade permission
                    message = message + " " + Resources.Resource.ERROR_ACCOUNT_NOT_TRADE_PERMISSION;
                    break;
                case CommonEnums.REJECT_REASON.ERROR_NOT_AVAILABLE_STOCK:
                    // No available stock
                    message = message + " " + Resources.Resource.ERROR_NOT_AVAILABLE_STOCK;
                    break;
                case CommonEnums.REJECT_REASON.ERROR_MARKET_CLOSE:
                    // Thi truong da dong cua
                    message = message + " " +
                              string.Format(Resources.Resource.ERROR_MARKET_CLOSE,
                                            ETradeCommon.Utils.GetMarketName(market));
                    break;
                //case CommonEnums.REJECT_REASON.ERROR_ATO_NOT_IN_READY_AND_SESSION1:
                //case CommonEnums.REJECT_REASON.ERROR_ATC_NOT_IN_SESSION3:
                //case CommonEnums.REJECT_REASON.NOT_CANCEL_ORDER_MATCHED:
                case CommonEnums.REJECT_REASON.ERROR_UPCOM_NOT_USE_ATO_ATC:
                    // No ATO or ATC for HNX
                    message = message + " " + Resources.Resource.ERROR_UPCOM_NOT_USE_ATO_ATC;
                    break;
                case CommonEnums.REJECT_REASON.ERROR_PRICE_NOT_MULTIPLE_100_FOR_UPCOM:
                    // Incorrect step price
                    message = message + " " + Resources.Resource.ERROR_PRICE_NOT_MULTIPLE_100_FOR_UPCOM;
                    break;
                default:
                    // Cannot put order. Unknown error
                    message = message + " " + string.Format(Resources.Resource.ERROR_DEFAULT, Constants.COMPANY_NAME);
                    break;
            }

            _accountManagerServices.SendMessage(mainCustAccountId, message);
        }

        /// <summary>
        /// Cancels the order.
        /// </summary>
        /// <param name="orderId">The order id.</param>
        /// <returns>ResultObject of CommonEnums.RET_CODE</returns>
        public ResultObject<int> CancelOrder(int orderId)
        {
            ExecOrder execOrder;

            try
            {
                execOrder = _execOrderService.GetByOrderId(orderId);
                if (execOrder == null)
                {
                    return new ResultObject<int>
                    {
                        ErrorMessage = CommonEnums.REJECT_REASON.INCORRECT_ORDER_NO.ToString(),
                        Result = (int)CommonEnums.REJECT_REASON.INCORRECT_ORDER_NO,
                        RetCode = CommonEnums.RET_CODE.FAIL
                    };
                }

                CommonEnums.REJECT_REASON rejectReason = _validateServices.IsValidCancelOrder(execOrder);

                if (rejectReason != CommonEnums.REJECT_REASON.IS_VALID)
                {
                    return new ResultObject<int>
                    {
                        ErrorMessage = rejectReason.ToString(),
                        Result = (int)rejectReason,
                        RetCode = CommonEnums.RET_CODE.FAIL
                    };
                }

                CommonEnums.RET_CODE retCode = _eTradeGW.CancelOrder(orderId);

                return new ResultObject<int>
                {
                    RetCode = retCode,
                    Result = (int)retCode,
                    ErrorMessage = retCode.ToString()
                };
            }
            catch (Exception exception)
            {
                LogHandler.Log("CancelOrder OrderID = " + orderId + " Exception = " + exception,
                    GetType() + ".CancelOrder()",
                                        TraceEventType.Error);

                return new ResultObject<int>
                {
                    ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString(),
                    Result = (int)CommonEnums.RET_CODE.SYSTEM_ERROR,
                    RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR
                };
            }
        }

        /// <summary>
        /// Gets the newest order status.
        /// </summary>
        /// <param name="pageSize">Size of the page.</param> 
        /// <param name="pageIndex">The page number.</param>
        /// <param name="accountId">The account id.</param>
        /// <param name="isPending">Is Pending.</param>
        /// <param name="isMatched">Is Matched.</param>
        /// <param name="isSemiMatched">Is SemiMatched.</param>
        /// <param name="isCanceling">Is Canceling.</param>
        /// <param name="isCancelled">Is Cancelled.</param>
        /// <param name="isRejected">IsRjected.</param>
        /// <returns>ResultObject is list of ExecOrder</returns>
        public ResultObject<PagingObject<List<ExecOrder>>> GetNewsestOrderStatus(
            int pageSize,
            int pageIndex,
            string accountId,
            bool isPending,
            bool isMatched,
            bool isSemiMatched,
            bool isCanceling,
            bool isCancelled,
            bool isRejected)
        {
            var resultObject = new ResultObject<PagingObject<List<ExecOrder>>>
            {
                RetCode = CommonEnums.RET_CODE.SUCCESS,
                Result = new PagingObject<List<ExecOrder>>(),
                ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString()
            };

            string whereClause = GetWhereClause(
                accountId, isPending, isMatched, isSemiMatched, isCanceling, isCancelled, isRejected);

            int totalCount = 0;

            var orders = new ETradeOrders.Entities.TList<ExecOrder>();
            if (pageIndex == 0)
            {
                // Get all pages
                orders = _execOrderService.GetPaged(
                whereClause, "OrderID DESC", pageIndex, int.MaxValue, out totalCount);
            }
            else if (pageIndex > 0)
            {
                orders = _execOrderService.GetPaged(
                whereClause, "OrderID DESC", pageIndex - 1, pageSize, out totalCount);
            }

            if (orders == null || orders.Count == 0)
            {
                resultObject.Result = new PagingObject<List<ExecOrder>>();
                resultObject.RetCode = CommonEnums.RET_CODE.NO_EXISTED_DATA;
                resultObject.ErrorMessage = CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString();

                return resultObject;
            }

            var result = new List<ExecOrder>();

            // validate this order can be canceled or not
            foreach (ExecOrder order in orders)
            {
                order.canCancel = (CommonEnums.REJECT_REASON.IS_VALID == _validateServices.IsValidCancelOrder(order)) ? true : false;
                result.Add(order);
            }

            resultObject.Result = new PagingObject<List<ExecOrder>>
            {
                Count = totalCount,
                Data = result
            };

            return resultObject;
        }

        /// <summary>
        /// Gets the newest order count.
        /// </summary>
        /// <param name="accountId">The account id.</param>
        /// <param name="isPending">Is Pending.</param>
        /// <param name="isMatched">Is Matched.</param>
        /// <param name="isSemiMatched">Is SemiMatched.</param>
        /// <param name="isCanceling">Is Canceling.</param>
        /// <param name="isCancelled">Is Cancelled.</param>
        /// <param name="isRejected">IsRjected.</param>
        /// <returns>int</returns>
        public ResultObject<int> GetNewsestOrderCount(string accountId, bool isPending, bool isMatched, bool isSemiMatched, bool isCanceling, bool isCancelled, bool isRejected)
        {
            var resultObject = new ResultObject<int> { RetCode = CommonEnums.RET_CODE.SUCCESS, Result = 0 };

            string whereClause = GetWhereClause(accountId, isPending, isMatched, isSemiMatched, isCanceling, isCancelled, isRejected);
            int totalCount;

            resultObject.Result = _execOrderService.GetTotalItems(whereClause, out totalCount);

            return resultObject;
        }

        /// <summary>
        /// Gets the GetWhereClause
        /// </summary>
        /// <param name="accountId">
        /// The account no.
        /// </param>
        /// <param name="isPending">
        /// From date.
        /// </param>
        /// <param name="isMatched">
        /// To date.
        /// </param>
        /// <param name="isSemiMatched">
        /// The symbol.
        /// </param>
        /// <param name="isCanceling">
        /// The order status.
        /// </param>
        /// <param name="isCancelled">
        /// The order status.
        /// </param>
        /// <param name="isRejected">
        /// The order status.
        /// </param>
        /// <returns>
        /// string
        /// </returns>
        private static string GetWhereClause(string accountId, bool isPending, bool isMatched, bool isSemiMatched,
            bool isCanceling, bool isCancelled, bool isRejected)
        {
            var whereClause = new StringBuilder();
            const string orString = " OR ";
            string whereString;

            if (isPending && isMatched && isSemiMatched && isCanceling && isCancelled && isRejected)
            {
                whereString = string.Format("SubCustAccountID = '{0}'", accountId);
            }
            else
            {
                if (isPending)
                {
                    whereClause.Append(
                        string.Format(
                            "(OrderStatus = {0} OR OrderStatus = {1} OR OrderStatus = {2})",
                            (int)CommonEnums.ORDER_STATUS.NEW_ORDER,
                            (int)CommonEnums.ORDER_STATUS.CONFIRMED_FIS,
                                                (int)CommonEnums.ORDER_STATUS.CONFIRMED_SET));
                }

                if (isMatched)
                {
                    whereClause.Append(orString);
                    whereClause.AppendFormat(" (OrderStatus = {0})", (int)CommonEnums.ORDER_STATUS.FULL_MATCHED);
                }

                if (isSemiMatched)
                {
                    whereClause.Append(orString);
                    whereClause.AppendFormat(
                        " (OrderStatus = {0} OR (ExecutedVol > 0 AND (((Volume - ExecutedVol) > 0) OR (CancelledVolume > 0))))",
                        (int)CommonEnums.ORDER_STATUS.SEMI_MATCHED);
                }

                if (isCanceling)
                {
                    whereClause.Append(orString);
                    whereClause.AppendFormat(
                        " (OrderStatus = {0} OR OrderStatus = {1})",
                        (int)CommonEnums.ORDER_STATUS.NEW_CANCEL,
                        (int)CommonEnums.ORDER_STATUS.WAITING_CANCEL);
                }

                if (isCancelled)
                {
                    whereClause.Append(orString);
                    whereClause.AppendFormat(" (OrderStatus = {0})", (int)CommonEnums.ORDER_STATUS.CANCELLED);
                }

                if (isRejected)
                {
                    whereClause.Append(orString);
                    whereClause.AppendFormat(
                        " (OrderStatus = {0} OR OrderStatus = {1})",
                        (int)CommonEnums.ORDER_STATUS.ORDER_REJECTED,
                        (int)CommonEnums.ORDER_STATUS.CANCEL_REJECTED);
                }

                whereString = whereClause.ToString();
                if (string.IsNullOrEmpty(whereString.Trim()))
                {
                    whereString = string.Format("SubCustAccountID = '{0}'", accountId);
                }
                else
                {
                    if (whereString.StartsWith(orString))
                    {
                        whereString = whereString.Substring(orString.Length, whereString.Length - orString.Length);
                    }
                    whereString = "SubCustAccountID = '" + accountId + "' AND (" + whereString + ")";
                }
            }

            return whereString;
        }
        #endregion

        #region Deal
        /// <summary>
        /// Gets the deal history.
        /// </summary>
        /// <param name="orderNo">The order no.</param>
        /// <param name="dealDate">The deal date.</param>
        /// <param name="page">The page.</param>
        /// <returns></returns>
        public ResultObject<List<DealHistory>> GetDealHistory(decimal orderNo, string dealDate, int page)
        {
            try
            {
                List<DealHistory> list = _dealServices.GetDealHistory(orderNo, dealDate, page);

                if (list == null)
                    return new ResultObject<List<DealHistory>>
                    {
                        ErrorMessage = CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                        Result = null,
                        RetCode = CommonEnums.RET_CODE.NO_EXISTED_DATA
                    };

                return new ResultObject<List<DealHistory>>
                {
                    ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString(),
                    Result = list,
                    RetCode = CommonEnums.RET_CODE.SUCCESS
                };
            }
            catch (Exception exception)
            {
                LogHandler.Log(
                    "GetDealHistory orderNo = " + orderNo + " dealDate = " + dealDate + " Exception = " + exception,
                    GetType() + ".PutOrder()",
                    TraceEventType.Error);

                return new ResultObject<List<DealHistory>>
                {
                    ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString(),
                    Result = null,
                    RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR
                };
            }
        }
        /// <summary>
        /// Gets the deal intra day.
        /// </summary>
        /// <param name="orderNo">The order no.</param>
        /// <param name="page">The page.</param>
        /// <returns>ResultObject of list of DealInfo</returns>
        public ResultObject<List<DealInfo>> GetDealIntraDay(decimal orderNo, int page)
        {
            List<DealInfo> list = _dealServices.GetDealIntraDay(orderNo, page);

            if (list == null)
                return new ResultObject<List<DealInfo>>
                {
                    ErrorMessage = CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                    Result = null,
                    RetCode = CommonEnums.RET_CODE.NO_EXISTED_DATA
                };

            return new ResultObject<List<DealInfo>>
            {
                ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString(),
                Result = list,
                RetCode = CommonEnums.RET_CODE.SUCCESS
            };
        }
        #endregion        

        #region Portfolio
        /// <summary>
        /// Caculates the portfolio.
        /// </summary>
        /// <param name="portfolioInfos">The portfolio infos.</param>
        /// <returns></returns>
        private void CaculatePortfolio(ref Dictionary<string, PortfolioInfo> portfolioInfos)
        {
            try
            {

                if (portfolioInfos != null)
                {
                    foreach (KeyValuePair<string, PortfolioInfo> portfolioInfo in portfolioInfos)
                    {
                        var stockInfo =
                            Serializer.Deserialize<ResultObject<StockInfo>>(
                                _rtServices.GetStockInfo(portfolioInfo.Value.Symbol));

                        if (stockInfo.Result != null)
                        {
                            portfolioInfo.Value.MarketPrice = ((Decimal)stockInfo.Result.Last > 0)
                                                                  ? (Decimal)stockInfo.Result.Last
                                                                  : (Decimal)stockInfo.Result.RefPrice;

                        }
                        else
                        {
                            portfolioInfo.Value.MarketPrice = 0;
                        }

                        if (stockInfo.Result != null)
                        {
                            if ((Decimal)stockInfo.Result.Last==0)
                            {
                                portfolioInfo.Value.GainLostToday = 0;
                            }
                            else
                            {
                                portfolioInfo.Value.GainLostToday =
                                ((Decimal)stockInfo.Result.Last - (Decimal)stockInfo.Result.RefPrice) *
                                (portfolioInfo.Value.Total - portfolioInfo.Value.WTR);
                                portfolioInfo.Value.GainLostToday =
                                    Math.Round(portfolioInfo.Value.GainLostToday * Constants.MONEY_UNIT, 2);
                            }
                            
                        }

                        portfolioInfo.Value.GainLoss = (portfolioInfo.Value.MarketPrice - portfolioInfo.Value.AvgPrice) *
                                                       (portfolioInfo.Value.Total - portfolioInfo.Value.WTR);

                        portfolioInfo.Value.GainLoss = Math.Round(portfolioInfo.Value.GainLoss * Constants.MONEY_UNIT, 2);

                        portfolioInfo.Value.InvestValue =
                            Math.Round(portfolioInfo.Value.AvgPrice * (portfolioInfo.Value.Total - portfolioInfo.Value.WTR) * Constants.MONEY_UNIT, 2);
                        portfolioInfo.Value.CurrentValue =
                            Math.Round(portfolioInfo.Value.MarketPrice * (portfolioInfo.Value.Total - portfolioInfo.Value.WTR) * Constants.MONEY_UNIT, 2);

                        if (portfolioInfo.Value.InvestValue != 0)
                        {
                            portfolioInfo.Value.Percent =
                                Math.Round((portfolioInfo.Value.GainLoss / portfolioInfo.Value.InvestValue) * 100, 2);
                        }
                        else if ((portfolioInfo.Value.Total - portfolioInfo.Value.WTR) > 0)
                        {
                            portfolioInfo.Value.Percent = 100;
                        }
                        else
                        {
                            portfolioInfo.Value.Percent = 0;
                        }
                    }
                }
            }
            catch (Exception exception)
            {
                LogHandler.Log(
                "CaculatePortfolio: Exception =" + exception,
                    GetType() + ".CaculatePortfolio()",
                    TraceEventType.Error);
            }
        }

        /// <summary>
        /// Caculate the profit and lost for each page or total portfolio (pageNumber == 0)
        /// </summary>
        /// <param name="portfolioInfos"></param>
        /// <param name="pageNumber"></param>
        /// <param name="pageSize"></param>
        /// <returns></returns>
        private static PortfolioInfo CaculateSumPortfolio(List<PortfolioInfo> portfolioInfos, int pageNumber, int pageSize)
        {
            var sumpage = new PortfolioInfo();

            try
            {
                int startIndex;
                int count;

                if (pageNumber == 0)
                {
                    startIndex = 0;
                    count = portfolioInfos.Count;
                }
                else
                {
                    startIndex = (pageNumber - 1) * pageSize;
                    int remainsItemCount = portfolioInfos.Count - startIndex;
                    count = (remainsItemCount > pageSize) ? pageSize : remainsItemCount;
                }

                var pagePortfolio = portfolioInfos.GetRange(startIndex, count);

                // Add a row for sumary portfolio
                sumpage.Total = 0;
                sumpage.CurrentValue = 0;
                sumpage.InvestValue = 0;

                foreach (PortfolioInfo item in pagePortfolio)
                {
                    if (item.Symbol != Constants.SUM_PORTFOLIO_PAGE &&
                        item.Symbol != Constants.SUM_PORTFOLIO_TOTAL)
                    {
                        sumpage.Total += item.Total;
                        sumpage.InvestValue += item.InvestValue;
                        sumpage.CurrentValue += item.CurrentValue;
                        sumpage.GainLostToday += item.GainLostToday;
                    }
                }

                sumpage.GainLoss = sumpage.CurrentValue - sumpage.InvestValue;

                if (sumpage.InvestValue != 0)
                {
                    sumpage.Percent = Math.Round(sumpage.GainLoss / sumpage.InvestValue * 100, 2);
                }
                else if (sumpage.GainLoss != 0)
                {
                    sumpage.Percent = 100;
                }
                else
                {
                    sumpage.Percent = 0;
                }


                sumpage.Symbol = pageNumber > 0 ? Constants.SUM_PORTFOLIO_PAGE : Constants.SUM_PORTFOLIO_TOTAL;


            }
            catch (Exception exception)
            {
                LogHandler.Log(
                "CaculateSumPortfolio: Exception =" + exception,
                    "CaculateSumPortfolio()",
                    TraceEventType.Error);
            }

            return sumpage;
        }

        /// <summary>
        /// Gets the portfolio.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <param name="pageNumber">The page number.</param>
        /// <param name="pageSize">Size of the page.</param>
        /// <param name="accountType">Type of the account.</param>
        /// <param name="subCustAccounts">The sub cust accounts.</param>
        /// <returns></returns>
        public ResultObject<PagingObject<List<PortfolioInfo>, PortfolioInfo, PortfolioInfo>> GetPortfolio(
            string accountNo, int pageNumber, int pageSize, int accountType, SubCustAccount subCustAccounts)
        {
            Dictionary<string, PortfolioInfo> portfolioInfos;

            try
            {
                portfolioInfos = _stockServices.GetPortfolioInfo(accountNo, accountType);

                if (portfolioInfos == null)
                {
                    return new ResultObject<PagingObject<List<PortfolioInfo>, PortfolioInfo, PortfolioInfo>>
                    {
                        ErrorMessage = CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                        RetCode = CommonEnums.RET_CODE.NO_EXISTED_DATA,
                        Result = new PagingObject<List<PortfolioInfo>, PortfolioInfo, PortfolioInfo>()
                    };
                }

                CaculatePortfolio(ref portfolioInfos);
            }
            catch (Exception exception)
            {
                LogHandler.Log(
                    "GetPortfolio: accountNo = " + accountNo + ", Exception = " + exception,
                    GetType() + ".GetPortfolio()",
                    TraceEventType.Error);

                return new ResultObject<PagingObject<List<PortfolioInfo>, PortfolioInfo, PortfolioInfo>>
                {
                    Result = null,
                    RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR,
                    ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString()
                };
            }

            if (portfolioInfos == null)
            {
                return new ResultObject<PagingObject<List<PortfolioInfo>, PortfolioInfo, PortfolioInfo>>
                {
                    ErrorMessage = CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                    Result = null,
                    RetCode = CommonEnums.RET_CODE.NO_EXISTED_DATA
                };
            }

            // Create the list of portfolio
            var listporfolio = new List<PortfolioInfo>();

            foreach (KeyValuePair<string, PortfolioInfo> portfolioInfo in portfolioInfos)
            {
                // should validate cansell by:
                // 1. market status 
                // 2. sellable share 
                // 3. canbuy/cansell permission.
                portfolioInfo.Value.CanSell = _validateServices.CanSell(
                    portfolioInfo.Value.Symbol, portfolioInfo.Value.SellableShare, accountNo, subCustAccounts);

                listporfolio.Add(portfolioInfo.Value);
            }

            var sumInPage = new PortfolioInfo();
            if (pageNumber > 0)
            {
                // caculate the sum profit and lost for this page.
                sumInPage = CaculateSumPortfolio(listporfolio, pageNumber, pageSize);
            }

            // caculate the sum profit and lost for total portfolio
            var totalSum = CaculateSumPortfolio(listporfolio, 0, 0);

            // paging
            List<PortfolioInfo> result = Paging(listporfolio, pageNumber, pageSize);

            return new ResultObject<PagingObject<List<PortfolioInfo>, PortfolioInfo, PortfolioInfo>>
            {
                RetCode = CommonEnums.RET_CODE.SUCCESS,
                Result =
                    new PagingObject<List<PortfolioInfo>, PortfolioInfo, PortfolioInfo>
                    {
                        Count = portfolioInfos.Count,
                        Data = result,
                        SumInPage = sumInPage,
                        TotalSum = totalSum
                    },
                ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString()
            };
        }

        /// <summary>
        /// Get the portfolio list.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <param name="accountType">Type of the account.</param>
        /// <returns></returns>
        public List<string> GetListPortfolio(string accountNo, int accountType)
        {
            var portfolioList = _stockServices.GetListPortfolio(accountNo, accountType);
            return portfolioList;
        }
        /// <summary>
        /// Gets the portfolio direct.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <param name="accounType">Type of the accoun.</param>
        /// <returns></returns>
        public ResultObject<List<Portfolio>> GetPortfolioDirect(string accountNo, int accounType)
        {
            List<Portfolio> returnVal = new List<Portfolio>();
            if (accounType == (int)CommonEnums.ACCOUNT_TYPE.NORMAL)
            {
                returnVal = _stockServices.GetPortfolioDirect4NormalAccount(accountNo);
            }

            return new ResultObject<List<Portfolio>>
            {
                ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString(),
                Result = returnVal,
                RetCode = CommonEnums.RET_CODE.SUCCESS
            };

        }
        #endregion
        
        #region paging

        /// <summary>
        /// Pagings the specified data.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <param name="pageIndex">Index of the page.</param>
        /// <param name="pageSize">Size of the page.</param>
        /// <returns></returns>
        private List<PortfolioInfo> Paging(List<PortfolioInfo> data, int pageIndex, int pageSize)
        {
            int startIndex;
            int count;

            if (pageIndex == 0)
            {
                startIndex = 0;
                count = data.Count;
            }
            else
            {
                startIndex = (pageIndex - 1) * pageSize;
                int remainsItemCount = data.Count - startIndex;
                count = (remainsItemCount > pageSize) ? pageSize : remainsItemCount;
            }

            var pagePortfolio = data.GetRange(startIndex, count);

            return pagePortfolio;
        }

        

        #endregion

        #region Trade
        /// <summary>
        /// Gets the state of the trading.
        /// </summary>
        /// <param name="marketId">The market id.</param>
        /// <returns>ResultObject of char</returns>
        public char GetTradingState(int marketId)
        {
            if (AppConfig.CheckGWConnection && !_eTradeGW.IsConnected())
            {
                return (char)CommonEnums.MARKET_STATUS.WAITING;
            }

            char tradingStatus = MarketServices.TradingStatus(marketId);

            return tradingStatus;
        }
        /// <summary>
        /// Gets the actual trade.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <param name="fromDate">From date.</param>
        /// <param name="toDate">To date.</param>
        /// <param name="symbol">The symbol.</param>
        /// <param name="pageNumber">The page number.</param>
        /// <param name="pageSize">Size of the page.</param>
        /// <returns></returns>
        public ResultObject<PagingObject<List<ActualTrade>>> GetActualTrade(string accountNo, string fromDate, string toDate, string symbol, int pageNumber, int pageSize)
        {
            List<ActualTrade> actualTrades = _actualTradeServices.GetActualTrading(accountNo, fromDate, toDate, symbol);

            if (actualTrades == null)
            {
                return new ResultObject<PagingObject<List<ActualTrade>>>
                {
                    ErrorMessage = CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                    Result = new PagingObject<List<ActualTrade>>(),
                    RetCode = CommonEnums.RET_CODE.NO_EXISTED_DATA
                };
            }

            // Paging actual trading
            int startIndex;
            int count;
            if (pageNumber == 0)
            {
                startIndex = 0;
                count = actualTrades.Count;
            }
            else
            {
                startIndex = (pageNumber - 1) * pageSize;
                int remainsItemCount = actualTrades.Count - startIndex;
                count = (remainsItemCount > pageSize) ? pageSize : remainsItemCount;
            }

            var returnValue = actualTrades.GetRange(startIndex, count);

            return new ResultObject<PagingObject<List<ActualTrade>>>
            {
                ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString(),
                Result = new PagingObject<List<ActualTrade>>
                {
                    Count = actualTrades.Count,
                    Data = returnValue
                },
                RetCode = CommonEnums.RET_CODE.SUCCESS
            };
        }
        /// <summary>
        /// Gets the pre trade info.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <param name="symbol">The symbol.</param>
        /// <param name="accountType">Type of the account.</param>
        /// <param name="side">The side.</param>
        /// <returns></returns>
        public ResultObject<PreTradeInfo> GetPreTradeInfo(string accountNo, string symbol, int accountType, char side)
        {
            ResultObject<PreTradeInfo> retObject = new ResultObject<PreTradeInfo>
            {
                ErrorMessage =
                    CommonEnums.RET_CODE.SYSTEM_ERROR.ToString(),
                Result = null,
                RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR
            };

            var stockInfo = Serializer.Deserialize<ResultObject<StockInfo>>(_rtServices.GetStockInfo(symbol));

            if (stockInfo.Result == null)
            {
                return retObject;
            }

            var tradingState = GetTradingState(stockInfo.Result.MarketID);

            if (side == (char)CommonEnums.TRADE_SIDE.BUY)
            {
                var cashAvailable = GetAvailableCash(accountNo, accountType);

                return new ResultObject<PreTradeInfo>
                {
                    ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString(),
                    Result =
                        new PreTradeInfo
                        {
                            CashAvailable = cashAvailable.Result,
                            StockInfo = stockInfo.Result,
                            TradingState = (CommonEnums.MARKET_STATUS)tradingState
                        },
                    RetCode = CommonEnums.RET_CODE.SUCCESS
                };
            }

            //for SELL side
            var stockAvailable = GetAvailableStock(accountNo, symbol, accountType);

            return new ResultObject<PreTradeInfo>
            {
                ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString(),
                Result =
                    new PreTradeInfo
                    {
                        StockAvailable = stockAvailable.Result,
                        StockInfo = stockInfo.Result,
                        TradingState = (CommonEnums.MARKET_STATUS)tradingState
                    },
                RetCode = CommonEnums.RET_CODE.SUCCESS
            };
        }
        #endregion        

        #region XD
        /// <summary>
        /// Pagings the specified data.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <param name="pageIndex">Index of the page.</param>
        /// <param name="pageSize">Size of the page.</param>
        /// <returns></returns>
        private List<XD> Paging(List<XD> data, int pageIndex, int pageSize)
        {
            int startIndex;
            int count;

            if (pageIndex == 0)
            {
                startIndex = 0;
                count = data.Count;
            }
            else
            {
                startIndex = (pageIndex - 1) * pageSize;
                int remainsItemCount = data.Count - startIndex;
                count = (remainsItemCount > pageSize) ? pageSize : remainsItemCount;
            }

            var xds = data.GetRange(startIndex, count);

            return xds;
        }
        /// <summary>
        /// Gets the XD info.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <param name="symbol">The symbol.</param>
        /// <param name="fromDate">From date.</param>
        /// <param name="toDate">To date.</param>
        /// <param name="pageIndex">Index of the page.</param>
        /// <param name="pageSize">Size of the page.</param>
        /// <returns></returns>
        public ResultObject<PagingObject<List<XD>>> GetXDInfo(string accountNo, string symbol, string fromDate, string toDate, int pageIndex, int pageSize)
        {
            List<XD> list = _stockServices.GetXDInfo(accountNo, symbol, fromDate, toDate);

            if (list == null)
            {
                return new ResultObject<PagingObject<List<XD>>>
                {
                    ErrorMessage = CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                    RetCode = CommonEnums.RET_CODE.NO_EXISTED_DATA,
                    Result = new PagingObject<List<XD>>()
                };
            }

            // Paging XD
            var returnValue = Paging(list, pageIndex, pageSize);

            return new ResultObject<PagingObject<List<XD>>>
            {
                ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString(),
                Result = new PagingObject<List<XD>>
                {
                    Data = returnValue,
                    Count = list.Count
                },
                RetCode = CommonEnums.RET_CODE.SUCCESS
            };
        }
        #endregion
        
        #region XR
        /// <summary>
        /// Pagings the specified data.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <param name="pageIndex">Index of the page.</param>
        /// <param name="pageSize">Size of the page.</param>
        /// <returns></returns>
        private List<XR> Paging(List<XR> data, int pageIndex, int pageSize)
        {
            int startIndex;
            int count;

            if (pageIndex == 0)
            {
                startIndex = 0;
                count = data.Count;
            }
            else
            {
                startIndex = (pageIndex - 1) * pageSize;
                int remainsItemCount = data.Count - startIndex;
                count = (remainsItemCount > pageSize) ? pageSize : remainsItemCount;
            }

            var xds = data.GetRange(startIndex, count);

            return xds;
        }
        /// <summary>
        /// Gets the XR info.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <param name="symbol">The symbol.</param>
        /// <param name="sellFromDate">The sell from date.</param>
        /// <param name="sellToDate">The sell to date.</param>
        /// <param name="transferFromDate">The transfer from date.</param>
        /// <param name="transferToDate">The transfer to date.</param>
        /// <param name="pageIndex">Index of the page.</param>
        /// <param name="pageSize">Size of the page.</param>
        /// <returns></returns>
        public ResultObject<PagingObject<List<XR>>> GetXRInfo(string accountNo, string symbol, string fromDate, string toDate, int xType, int pageIndex, int pageSize)
        {
            List<XR> list = _stockServices.GetXRInfo(
                accountNo, symbol, fromDate, toDate, xType);



            if (list == null)
            {
                return new ResultObject<PagingObject<List<XR>>>
                {
                    ErrorMessage = CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                    RetCode = CommonEnums.RET_CODE.NO_EXISTED_DATA,
                    Result = new PagingObject<List<XR>>()
                };
            }

            if (xType == (int)CommonEnums.RIGHTTYPE.ALL_RIGHT)
            {
                List<XR> retList = new List<XR>();

                foreach (var item in list)
                {
                    if ((int)item.xType == (int)CommonEnums.RIGHTTYPE.STOCK_DIVIDENT ||
                        (int)item.xType == (int)CommonEnums.RIGHTTYPE.STOCK_BONUS)
                    {
                        retList.Add(item);
                    }
                }

                // Paging XR
                var returnValueAll = Paging(retList, pageIndex, pageSize);

                return new ResultObject<PagingObject<List<XR>>>
                {
                    ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString(),
                    Result = new PagingObject<List<XR>>
                    {
                        Data = returnValueAll,
                        Count = retList.Count
                    },
                    RetCode = CommonEnums.RET_CODE.SUCCESS
                };
            }
            // Paging XR
            var returnValue = Paging(list, pageIndex, pageSize);

            return new ResultObject<PagingObject<List<XR>>>
            {
                ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString(),
                Result = new PagingObject<List<XR>>
                {
                    Data = returnValue,
                    Count = list.Count
                },
                RetCode = CommonEnums.RET_CODE.SUCCESS
            };
        }
        #endregion
   
        #region system configuration

        /// <summary>
        /// Saves the config.
        /// </summary>
        /// <param name="holidayses">The holidayses.</param>
        public static void SaveHolidayConfig(IEnumerable<Holidays> holidayses)
        {
            foreach (var holidayse in holidayses)
            {
                if (!SysConfig.Holidays.ContainsKey(holidayse.Holiday.ToString("yyyyMMdd")))
                {
                    SysConfig.Holidays.Add(holidayse.Holiday.ToString("yyyyMMdd"), holidayse.Holiday);
                }
                else
                {
                    SysConfig.Holidays[holidayse.Holiday.ToString("yyyyMMdd")] = holidayse.Holiday;
                }
            }
        }

        /// <summary>
        /// Saves the working days config.
        /// </summary>
        /// <param name="workingDayses">The working dayses.</param>
        public static void SaveWorkingDaysConfig(IEnumerable<WorkingDays> workingDayses)
        {
            foreach (var workingDayse in workingDayses)
            {
                if (!SysConfig.WorkingDays.ContainsKey(workingDayse.DateId))
                {
                    SysConfig.WorkingDays.Add(workingDayse.DateId, workingDayse.IsWorkingDay);
                }
                else
                {
                    SysConfig.WorkingDays[workingDayse.DateId] = workingDayse.IsWorkingDay;
                }
            }
        }

        /// <summary>
        /// Saves all configuration.
        /// </summary>
        /// <param name="configurationses">The configurationses.</param>
        public static void SaveAllConfiguration(List<Configurations> configurationses)
        {
            foreach (Configurations configurationse in configurationses)
            {
                if (!SysConfig.Configurations.ContainsKey(configurationse.Name))
                {
                    SysConfig.Configurations.Add(configurationse.Name, configurationse.Value);
                }
                else
                {
                    SysConfig.Configurations[configurationse.Name] = configurationse.Value;
                }
            }
        }

        /*/// <summary>
        /// Saves the advance time.
        /// </summary>
        /// <param name="advanceTimes">The advance times.</param>
        public static void SaveAdvanceTime(List<AdvanceTime> advanceTimes)
        {
            foreach (AdvanceTime advanceTime in advanceTimes)
            {
                if (!SysConfig.AdvanceTimes.ContainsKey(advanceTime.AdvanceType))
                {
                    SysConfig.AdvanceTimes.Add(advanceTime.AdvanceType, advanceTime);
                }
                else
                {
                    SysConfig.AdvanceTimes[advanceTime.AdvanceType] = advanceTime;
                }
            }
        }*/

        #endregion
        
        #region Cash Advance
        /// <summary>
        /// Gets the advance history.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <param name="fromAdvanceDate">From advance date.</param>
        /// <param name="toAdvanceDate">To advance date.</param>
        /// <param name="fromSellDate">From sell date.</param>
        /// <param name="toSellDate">To sell date.</param>
        /// <param name="advanceStatus">The advance status.</param>
        /// <param name="contractNo">The contract no.</param>
        /// <param name="pageIndex">Index of the page.</param>
        /// <param name="pageSize">Size of the page.</param>
        /// <returns></returns>
        public ResultObject<PagingObject<List<CashAdvance>>> GetAdvanceHistory(
            string accountNo,
            string fromAdvanceDate,
            string toAdvanceDate,
            string fromSellDate,
            string toSellDate,
            int advanceStatus,
            string contractNo,
            int pageIndex,
            int pageSize)
        {
            List<CashAdvance> cashAdvHistFromCore = null;
            List<CashAdvance> cashAdvHistFromOtsDb = null;

            switch (advanceStatus)
            {
                case (int)CommonEnums.ADVANCE_STATUS.FINISHED:
                    // Get advance finished from core
                    cashAdvHistFromCore = _cashAdvanceServices.GetAdvanceHistoryFromCore(
                        accountNo, fromAdvanceDate, toAdvanceDate, fromSellDate, toSellDate, contractNo);
                    break;
                case (int)CommonEnums.ADVANCE_STATUS.CANCELLED:
                case (int)CommonEnums.ADVANCE_STATUS.PENDING:
                case (int)CommonEnums.ADVANCE_STATUS.REJECTED:
                case (int)CommonEnums.ADVANCE_STATUS.PROCESSING:
                    // Get advance history (cancelled, rejected) from Ots database
                    cashAdvHistFromOtsDb = _cashAdvanceServices.GetAdvanceHistoryFromOtsDb(
                        accountNo, fromAdvanceDate, toAdvanceDate, fromSellDate, toSellDate, advanceStatus, contractNo);
                    break;
                case (int)CommonEnums.ADVANCE_STATUS.ALL:
                    // Get advance finished from core
                    cashAdvHistFromCore = _cashAdvanceServices.GetAdvanceHistoryFromCore(
                        accountNo, fromAdvanceDate, toAdvanceDate, fromSellDate, toSellDate, contractNo);

                    // Get advance history (cancelled, rejected) from Ots database
                    cashAdvHistFromOtsDb = _cashAdvanceServices.GetAdvanceHistoryFromOtsDb(
                        accountNo, fromAdvanceDate, toAdvanceDate, fromSellDate, toSellDate, advanceStatus, contractNo);
                    break;

                default:
                    break;


            }

            // No data found
            if ((cashAdvHistFromCore == null && cashAdvHistFromOtsDb == null) ||
                ((cashAdvHistFromCore != null && cashAdvHistFromCore.Count == 0)
                && (cashAdvHistFromOtsDb != null && cashAdvHistFromOtsDb.Count == 0)))
            {
                return new ResultObject<PagingObject<List<CashAdvance>>>
                {
                    ErrorMessage = CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                    Result = new PagingObject<List<CashAdvance>>(),
                    RetCode = CommonEnums.RET_CODE.NO_EXISTED_DATA
                };
            }

            var totalCashAdvance = new List<CashAdvance>();

            // Join cash advance from core and cash advance from Otsdb
            if (cashAdvHistFromCore != null)
            {
                totalCashAdvance.AddRange(cashAdvHistFromCore);
            }

            if (cashAdvHistFromOtsDb != null)
            {
                totalCashAdvance.AddRange(cashAdvHistFromOtsDb);
            }

            // Paging advance history
            int startIndex = 0;
            int count = 0;

            if (pageIndex == 0)
            {
                startIndex = 0;
                count = totalCashAdvance.Count;
            }
            else
            {
                startIndex = (pageIndex - 1) * pageSize;
                int remainsItemCount = totalCashAdvance.Count - startIndex;
                count = (remainsItemCount > pageSize) ? pageSize : remainsItemCount;
            }

            var returnValue = totalCashAdvance.GetRange(startIndex, count);

            return new ResultObject<PagingObject<List<CashAdvance>>>
            {
                ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString(),
                Result = new PagingObject<List<CashAdvance>>
                {
                    Data = returnValue,
                    Count = totalCashAdvance.Count
                },
                RetCode = CommonEnums.RET_CODE.SUCCESS
            };
        }
        /// <summary>
        /// Gets the cash advance status.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <param name="fromDate">From date.</param>
        /// <param name="toDate">To date.</param>
        /// <param name="status">The status.</param>
        /// <param name="pageIndex">Index of the page.</param>
        /// <param name="pageSize">Size of the page.</param>
        /// <returns></returns>
        public ResultObject<PagingObject<List<ETradeFinance.Entities.CashAdvance>>> GetCashAdvanceStatus(string accountNo, string fromDate, string toDate, int status, int pageIndex, int pageSize)
        {
            try
            {
                var cashAdvances =
                _cashAdvanceServices.GetCashAdvanceStatus(accountNo, fromDate, toDate, status, pageIndex, pageSize);

                if (cashAdvances == null || cashAdvances.Data == null)
                {
                    LogHandler.Log(
                    "GetCashAdvanceStatus: NO_EXISTED_DATA, accountNo = " + accountNo + ", fromDate = " +
                    fromDate + ", toDate = " + toDate + ", status = " + status + ", pageIndex = " + pageIndex +
                    ", pageSize = " + pageSize,
                    GetType() + ".GetCashAdvanceStatus()",
                    TraceEventType.Information);
                    return new ResultObject<PagingObject<List<ETradeFinance.Entities.CashAdvance>>>
                    {
                        ErrorMessage = CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                        Result = new PagingObject<List<ETradeFinance.Entities.CashAdvance>>(),
                        RetCode = CommonEnums.RET_CODE.NO_EXISTED_DATA
                    };
                }

                return new ResultObject<PagingObject<List<ETradeFinance.Entities.CashAdvance>>>
                {
                    ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString(),
                    Result = cashAdvances,
                    RetCode = CommonEnums.RET_CODE.SUCCESS
                };
            }
            catch (Exception exception)
            {
                LogHandler.Log(
                    "GetCashAdvanceStatus: exception = " + exception + " accountNo = " + accountNo + ", fromDate = " +
                    fromDate + ", toDate = " + toDate + ", status = " + status + ", pageIndex = " + pageIndex +
                    ", pageSize = " + pageSize,
                    GetType() + ".GetCashAdvanceStatus()",
                    TraceEventType.Error);

                return new ResultObject<PagingObject<List<ETradeFinance.Entities.CashAdvance>>>
                {
                    ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString(),
                    Result = new PagingObject<List<ETradeFinance.Entities.CashAdvance>>(),
                    RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR
                };
            }
        }
        /// <summary>
        /// Gets the advance info.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <returns></returns>
        public ResultObject<PagingObject<List<AdvanceInfo>, AdvanceInfo, AdvanceInfo>> GetAdvanceInfo(string accountNo)
        {
            var newestWorkingDatesInfo = Serializer.Deserialize<ResultObject<List<NewestWorkingDatesInfo>>>(_rtServices.GetNewestWorkingDates());

            if (newestWorkingDatesInfo == null || newestWorkingDatesInfo.Result == null || newestWorkingDatesInfo.RetCode != CommonEnums.RET_CODE.SUCCESS)
            {
                LogHandler.Log(
                    "GetAdvanceInfo: GetNewestWorkingDates of RTServices return null",
                    GetType() + ".GetAdvanceInfo()",
                    TraceEventType.Warning);
                return new ResultObject<PagingObject<List<AdvanceInfo>, AdvanceInfo, AdvanceInfo>>
                {
                    ErrorMessage = CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                    Result = new PagingObject<List<AdvanceInfo>, AdvanceInfo, AdvanceInfo>(),
                    RetCode = CommonEnums.RET_CODE.NO_EXISTED_DATA
                };
            }

            newestWorkingDatesInfo.Result[0].T = newestWorkingDatesInfo.Result[0].T.ToLocalTime();
            newestWorkingDatesInfo.Result[0].T1 = newestWorkingDatesInfo.Result[0].T1.ToLocalTime();
            newestWorkingDatesInfo.Result[0].T2 = newestWorkingDatesInfo.Result[0].T2.ToLocalTime();
            newestWorkingDatesInfo.Result[0].T3 = newestWorkingDatesInfo.Result[0].T3.ToLocalTime();

            List<AdvanceInfo> advanceInfos = _cashAdvanceServices.GetAdvanceInfo(accountNo,
                                                                                 newestWorkingDatesInfo.Result[0],
                                                                                 SysConfig.AdvanceTimes,
                                                                                 SysConfig.Holidays,
                                                                                 SysConfig.WorkingDays);

            var sumInPage = new AdvanceInfo();

            if (advanceInfos == null)
                return new ResultObject<PagingObject<List<AdvanceInfo>, AdvanceInfo, AdvanceInfo>>
                {
                    ErrorMessage = CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                    Result = new PagingObject<List<AdvanceInfo>, AdvanceInfo, AdvanceInfo>(),
                    RetCode = CommonEnums.RET_CODE.NO_EXISTED_DATA
                };

            foreach (var advanceInfo in advanceInfos)
            {
                sumInPage.SellAmt += advanceInfo.SellAmt;
                sumInPage.MaxCanAdvance += advanceInfo.MaxCanAdvance;
                sumInPage.AdvanceFinished += advanceInfo.AdvanceFinished;
            }

            return new ResultObject<PagingObject<List<AdvanceInfo>, AdvanceInfo, AdvanceInfo>>
            {
                ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString(),
                Result = new PagingObject<List<AdvanceInfo>, AdvanceInfo, AdvanceInfo>
                {
                    Count = advanceInfos.Count,
                    Data = advanceInfos,
                    SumInPage = sumInPage,
                    TotalSum = new AdvanceInfo()
                },
                RetCode = CommonEnums.RET_CODE.SUCCESS
            };
        }

        /// <summary>
        /// News the cash advance.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <param name="sellAmt">The sell amt.</param>
        /// <param name="cashAdvance">The cash advance.</param>
        /// <param name="maxCanAdvance">The max can advance.</param>
        /// <param name="tradeDate">The trade date.</param>
        /// <returns></returns>
        public ResultObject<string> NewCashAdvance(string accountNo,
            decimal sellAmt,
            decimal cashAdvance,
            decimal maxCanAdvance,
            string tradeDate)
        {
            CommonEnums.RET_CODE retCode = CommonEnums.RET_CODE.SUCCESS;

            // calculate dueDate
            DateTime dueDate = _cashAdvanceServices.CalculateDueDate(tradeDate, SysConfig.Holidays, SysConfig.WorkingDays);

            decimal advanceFee = _cashAdvanceServices.CalculateAdvanceFee(cashAdvance, dueDate);

            // TODO: shoule calculate tax per advance fee
            decimal tax = 0;

            // Validate new advance
            retCode = _cashAdvanceServices.IsValidAdvance(maxCanAdvance, cashAdvance, dueDate, advanceFee, tax,
                                                          SysConfig.AdvanceTimes, SysConfig.Holidays,
                                                          SysConfig.WorkingDays);
            if (retCode != CommonEnums.RET_CODE.SUCCESS)
            {
                return new ResultObject<string>
                {
                    RetCode = retCode,
                    ErrorMessage = retCode.ToString(),
                    Result = string.Empty
                };
            }

            //validate the amount of advance
            if (cashAdvance > _cashAdvanceServices.GetMaxAdvance(accountNo, tradeDate, SysConfig.AdvanceTimes, SysConfig.Holidays, SysConfig.WorkingDays))
            {
                retCode = CommonEnums.RET_CODE.ERROR_NOT_ENOUGH_CASH_TO_ADVANCE;
                return new ResultObject<string>
                {
                    RetCode = retCode,
                    ErrorMessage = retCode.ToString(),
                    Result = string.Empty
                };
            }

            DateTime _tradeDate;

            try
            {
                // convert trade date string to DateTime value
                _tradeDate = new DateTime(
                    int.Parse(tradeDate.Substring(0, 4)),
                    int.Parse(tradeDate.Substring(4, 2)),
                    int.Parse(tradeDate.Substring(6, 2)));
            }
            catch
            {
                _tradeDate = new DateTime();
                LogHandler.Log(
                    "NewCashAdvance: tradeDate was incorrect format (yyyyMMdd), tradeDate = " + tradeDate,
                    GetType() + ".NewCashAdvance()",
                    TraceEventType.Warning);
            }

            var contractNo = _cashAdvanceServices.BuildContractNo(DateTime.Now);

            var advanceInfo = new ETradeFinance.Entities.CashAdvance
            {
                ContractNo = contractNo,
                SubAccountId = accountNo,
                AdvanceDate = DateTime.Now,
                CashReceived = 0,
                Fee = advanceFee,
                Status = (int)CommonEnums.ADVANCE_STATUS.PENDING,
                SellDueDate = _tradeDate,
                CashDueDate = dueDate,
                Vat = tax,
                CashAvailable = maxCanAdvance,
                Reason = string.Empty,
                TotalSellValue = sellAmt,
                CashRequest = cashAdvance
            };

            // Insert new advance to DB
            bool result =
                _cashAdvanceServices.InsertCashAdvance(advanceInfo);

            //Update to cashAdvanceHistories.
            if (result)
            {
                var advanceInfoHistory = new CashAdvanceHistory()
                {
                    ContractNo = contractNo,
                    SubAccountId = accountNo,
                    AdvanceDate = DateTime.Now,
                    CashReceived = 0,
                    Fee = advanceFee,
                    Status = (int)CommonEnums.ADVANCE_STATUS.PENDING,
                    SellDueDate = _tradeDate,
                    CashDueDate = dueDate,
                    Vat = tax,
                    CashAvilable = maxCanAdvance,
                    Reason = string.Empty,
                    TotalSellValue = sellAmt,
                    CashRequest = cashAdvance
                };
                result = _cashAdvanceServices.InsertCashAdvanceHistory(advanceInfoHistory);
            }

            retCode = !result ? CommonEnums.RET_CODE.SYSTEM_ERROR : CommonEnums.RET_CODE.SUCCESS;

            return new ResultObject<string>
            {
                ErrorMessage = retCode.ToString(),
                Result = contractNo,
                RetCode = retCode
            };
        }

        /// <summary>
        /// Cancels the advance.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <param name="contractNo">The contract no.</param>
        /// <returns></returns>
        public CommonEnums.RET_CODE CancelAdvance(string accountNo, string contractNo)
        {
            var cashAdvanceService = new CashAdvanceService();
            var cashAdvanceHistoryService = new CashAdvanceHistoryService();

            string whereClause = string.Format(" ContractNo = '{0}' AND SubAccountId = '{1}'", contractNo, accountNo);
            int totalRecords = 0;

            var cashAdvances =
                cashAdvanceService.GetPaged(whereClause, "ID DESC", 0, int.MaxValue, out totalRecords);

            var cashAdvance = cashAdvances[0];

            var retCode = _cashAdvanceServices.IsValidCancelAdvance(cashAdvance);

            if (retCode != CommonEnums.RET_CODE.SUCCESS)
            {
                return retCode;
            }

            cashAdvance.Status = (int)CommonEnums.ADVANCE_STATUS.CANCELLED;
            cashAdvance.Fee = 0;
            cashAdvance.ExecTime = DateTime.Now;
            bool result = cashAdvanceService.Update(cashAdvance);

            //Update to cashAdvanceHistories.
            if (result)
            {
                var cashAdvanceHistories = cashAdvanceHistoryService.GetPaged(whereClause, "ID DESC", 0, int.MaxValue, out totalRecords);
                var cashAdvanceHistory = cashAdvanceHistories[0];
                cashAdvanceHistory.Status = (int)CommonEnums.ADVANCE_STATUS.CANCELLED;
                cashAdvanceHistory.Fee = 0;
                cashAdvanceHistory.ExecTime = DateTime.Now;
                result = cashAdvanceHistoryService.Update(cashAdvanceHistory);
            }

            return !result ? CommonEnums.RET_CODE.SYSTEM_ERROR : CommonEnums.RET_CODE.SUCCESS;
        }
        #endregion

        #region Bank Account Info
        /// <summary>
        /// Gets the bank account info.
        /// </summary>
        /// <param name="acccountNo">The acccount no.</param>
        /// <returns></returns>
        public ResultObject<BankAccountInfo> GetBankAccountInfo(string acccountNo)
        {
            BankAccountInfo bankAccountInfo = _bankServices.GetBankAccountInfo(acccountNo);
            if(bankAccountInfo!=null)
            {
                return new ResultObject<BankAccountInfo>()
                {
                    Result = bankAccountInfo,
                    ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString(),
                    RetCode = CommonEnums.RET_CODE.SUCCESS
                };
            }
            else
            {
                return new ResultObject<BankAccountInfo>()
                           {
                               Result = null,
                               ErrorMessage = CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                               RetCode = CommonEnums.RET_CODE.NO_EXISTED_DATA
                           };
            }
        }
        #endregion

        #region Margin
        /// <summary>
        /// Determines whether [is call margin] [the specified account no].
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <returns>Return ResultObject bool</returns>
        public ResultObject<bool> IsCallMargin(string accountNo)
        {
           return new ResultObject<bool>()
                      {
                          Result = _marginServices.IsCallMargin(accountNo),
                          ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS.ToString(),
                          RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS
                      };
        }
        /// <summary>
        /// Determines whether [is call force sell] [the specified account no].
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <returns></returns>
        public ResultObject<bool> IsCallForceSell(string accountNo)
        {
            return new ResultObject<bool>()
                       {
                           Result = _marginServices.IsCallForceSell(accountNo),
                           ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS.ToString(),
                           RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS
                       };
        }

        /// <summary>
        /// Gets the margin ratio.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <returns>The ResultObject MarginRatioInfo</returns>
        public ResultObject<MarginRatioInfo> GetMarginRatio(string accountNo)
        {
            MarginRatioInfo marginRatioInfo = _marginServices.GetMarginRatio(accountNo);
            if(marginRatioInfo==null)
            {
                return new ResultObject<MarginRatioInfo>()
                           {
                               Result = null,
                               ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                               RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA
                           };
            }
            else
            {
                return new ResultObject<MarginRatioInfo>()
                           {
                               Result = marginRatioInfo,
                               ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS.ToString(),
                               RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS
                           };
            }
        }

        /// <summary>
        /// Gets the margin portfolio.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <param name="pageIndex">Index of the page, default page size is 10.</param>
        /// <returns>Resutl object list Margin Portfolio</returns>
        public ResultObject<List<MarginPortfolio>> GetMarginPortfolio(string accountNo)
        {
            List<MarginPortfolio> listMarginPortfolio = _marginServices.GetMarginPortfolio(accountNo);
            if(listMarginPortfolio==null || listMarginPortfolio.Count==0)
            {
                return new ResultObject<List<MarginPortfolio>>()
                           {
                               Result = null,
                               ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                               RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA
                           };
            }
            else
            {
                return new ResultObject<List<MarginPortfolio>>()
                {
                    Result = listMarginPortfolio,
                    ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS.ToString(),
                    RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS
                };
            }
        }

        #endregion

        #region Cash Transfer
        /// <summary>
        /// Puts the cash trans order.
        /// </summary>
        /// <param name="sourceAccountID">The source account ID.</param>
        /// <param name="destAccountID">The dest account ID.</param>
        /// <param name="requestAmt">The request amt.</param>
        /// <param name="transType">Type of the trans.</param>
        /// <param name="note">The note.</param>
        /// <returns></returns>
        public int PutCashTransOrder(List<AccountManager.Entities.SubCustAccount> TlistSubCustAccount, string sourceAccountID, string destAccountID,decimal requestAmt, int transType, string note)
        {
            try
            {
                if (TlistSubCustAccount == null)
                    return (int) ETradeCommon.Enums.CommonEnums.RET_CODE.FAIL;

                //only account with margin type can do
                SubCustAccount subCustAccount=TlistSubCustAccount.Where(n => n.SubCustAccountId.Equals(sourceAccountID)).FirstOrDefault();
                if(subCustAccount==null)
                    return (int) ETradeCommon.Enums.CommonEnums.RET_CODE.ERROR_ACCOUNT;

                int bankAccountType = (int)subCustAccount.BankAccountType;
                if (bankAccountType == (int)ETradeCommon.Enums.CommonEnums.BANK_ACCOUNT_TYPE.BANKACC)
                    return (int)ETradeCommon.Enums.CommonEnums.RET_CODE.NOT_ALLOW;

                //check valid account & same in a main account       
                //if (TlistSubCustAccount.Where(n => n.SubCustAccountId.Equals(sourceAccountID)).Count() == 0 || TlistSubCustAccount.Where(n => n.SubCustAccountId.Equals(destAccountID)).Count() == 0)                               
                //    return (int) ETradeCommon.Enums.CommonEnums.RET_CODE.ERROR_NOT_SAME_ACCOUNT;

                //check Request Amount 
                if (requestAmt <= 0)
                    return (int) ETradeCommon.Enums.CommonEnums.RET_CODE.ERROR_REQUEST_AMOUNT;

                ResultObject<CashTransferInfo> resultObjectCashTransferInfo = GetCashTransferInfo(sourceAccountID,
                                                                        ETradeCommon.Utils.GetAccountType(sourceAccountID));

                if (resultObjectCashTransferInfo.RetCode == CommonEnums.RET_CODE.SUCCESS && resultObjectCashTransferInfo.Result != null)
                {
                    //Request Amount > Available Amount -> fail
                    if (resultObjectCashTransferInfo.Result.AvilableAmt < requestAmt)
                        return (int)ETradeCommon.Enums.CommonEnums.RET_CODE.ERROR_REQUEST_AMOUNT;

                    CashTransfer cashTransfer=new CashTransfer();
                    cashTransfer.WithdrawableAmt = resultObjectCashTransferInfo.Result.WithdrawableAmt;
                    cashTransfer.TransferedAmt = resultObjectCashTransferInfo.Result.TransferedAmt;
                    cashTransfer.AdvOrderAmt = resultObjectCashTransferInfo.Result.AdvOrderAmt;
                    cashTransfer.AvilableAmt = resultObjectCashTransferInfo.Result.AvilableAmt;
                    cashTransfer.RequestAmt = requestAmt;
                    cashTransfer.RequestTime = DateTime.Now;
                    cashTransfer.Fee = 0;
                    cashTransfer.Vat = 0;
                    cashTransfer.AmtAfterFee = cashTransfer.RequestAmt - cashTransfer.Fee;
                    cashTransfer.SrcAccountId = sourceAccountID;
                    cashTransfer.DestAccountId = destAccountID;
                    cashTransfer.TransType = transType;
                    cashTransfer.Status =(int) ETradeCommon.Enums.CommonEnums.CASH_TRANSFER_STATUS.PENDING;
                    cashTransfer.ApprovedAmt = 0;
                                                            
                    // transfer from Account Type 6 to 1
                    if (ETradeCommon.Utils.GetAccountType(sourceAccountID) == (int)CommonEnums.ACCOUNT_TYPE.MARGIN && ETradeCommon.Utils.GetAccountType(destAccountID) == (int)CommonEnums.ACCOUNT_TYPE.NORMAL)
                    {
                        //check invalid with drawal
                        if (cashTransfer.WithdrawableAmt < 0)
                            return (int)ETradeCommon.Enums.CommonEnums.RET_CODE.ERROR_INVALID_WITHDRAWAL;
                    }
                    return _cashTransferService.PutCashTransOrder(cashTransfer);
                }
                else
                    return (int) CommonEnums.RET_CODE.ERROR_NOT_CASH_AVAILABLE;
            }
            catch (Exception e)
            {
                return (int) ETradeCommon.Enums.CommonEnums.RET_CODE.SYSTEM_ERROR;
            }
        }

        /// <summary>
        /// Gets the list unfinished cash transfer.
        /// </summary>
        /// <param name="subAccountId">The sub Account Id</param>
        /// <returns>ResultObject List CashTransfer</returns>
        public ResultObject<List<CashTransfer>> GetListUnfinishedCashTransfer(string subAccountId)
        {
            List<CashTransfer> listUnfinishedCashTransfer = _cashTransferService.GetListUnfinishedCashTransfer(subAccountId);
            if(listUnfinishedCashTransfer!=null && listUnfinishedCashTransfer.Count>0)
            {
                return new ResultObject<List<CashTransfer>>()
                           {
                               Result = listUnfinishedCashTransfer,
                               ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS.ToString(),
                               RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS
                           };
            }
            else
            {
                return new ResultObject<List<CashTransfer>>()
                {
                    Result = null,
                    ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                    RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA
                };
            }
        }

        /// <summary>
        /// Gets the total unfinished transfer amount (on status pending or processing)
        /// </summary>
        /// <param name="subAccountId">The sub account id.</param>
        /// <returns></returns>
        public decimal GetTotalUnfinishedTransferAmount(string subAccountId)
        {
            return _cashTransferService.GetTotalUnfinishedCashTransferAmount(subAccountId);
        }

        /// <summary>
        /// Gets the cash transfer info.
        /// </summary>
        /// <param name="subAccountId">The subAccountId.</param>
        /// <param name="accountType">Type of the account.</param>
        /// <returns>ResultObject CashTransferInfo</returns>
        public ResultObject<CashTransferInfo> GetCashTransferInfo(string subAccountId, int accountType)
        {
            CashBalance cashBalance = _cashServices.GetCashBalance(subAccountId, accountType);
            if(cashBalance!=null)
            {
                CashTransferInfo cashTransferInfo = new CashTransferInfo();
                cashTransferInfo.subAccountId = subAccountId;
                cashTransferInfo.WithdrawableAmt = cashBalance.WithDraw;
          
                cashTransferInfo.AdvOrderAmt =
                    _validateServices.GetTotalConditionOrderMoney((char)ETradeCommon.Enums.CommonEnums.TRADE_SIDE.BUY,
                                                                 subAccountId,-1);                            

                cashTransferInfo.TransferedAmt = GetTotalUnfinishedTransferAmount(subAccountId);
                
                /*cashTransferInfo.AvilableAmt = cashTransferInfo.WithdrawableAmt - cashTransferInfo.AdvOrderAmt -
                                               cashTransferInfo.TransferedAmt;*/

                cashTransferInfo.AvilableAmt = cashTransferInfo.WithdrawableAmt - cashTransferInfo.TransferedAmt;

                return new ResultObject<CashTransferInfo>()
                           {
                               Result = cashTransferInfo,
                               ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS.ToString(),
                               RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS
                           };
            }
            else
            {
                return new ResultObject<CashTransferInfo>()
                           {
                                Result=null,
                                ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                                RetCode =ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA
                           };
            }
        }

        /// <summary>
        /// Cashes the trans order hist.
        /// </summary>
        /// <param name="sourceAccountID">The source account ID.</param>
        /// <param name="destAccountID">The dest account ID.</param>
        /// <param name="fromDate">From date.</param>
        /// <param name="toDate">To date.</param>
        /// <param name="transType">Type of the trans.</param>
        /// <param name="status">The status.</param>
        /// <param name="note">The note.</param>
        /// <param name="brokerID">The broker ID.</param>
        /// <param name="pageIndex">Index of the page.</param>
        /// <param name="pageSize">Size of the page.</param>
        /// <returns>ResultObject PagingObject List CashTransfer </returns>
        public ResultObject<PagingObject<List<CashTransfer>>> GetListCashTransOrderHist(string sourceAccountID,string destAccountID,string fromDate,string toDate,int transType,int status,string note,string brokerID,int pageIndex,int pageSize)
        {    
            try
            {
                // convert from date string to DateTime value
                if (!string.IsNullOrEmpty(fromDate))
                {
                    var fromDateSearch=new DateTime(
                    int.Parse(fromDate.Substring(0, 4)),
                    int.Parse(fromDate.Substring(4, 2)),
                    int.Parse(fromDate.Substring(6, 2)));
                    fromDate = fromDateSearch.ToString("dd/MM/yyyy");
                }                
            }
            catch
            {               
                LogHandler.Log(
                    "GetListCashTransOrderHist: fromDate was incorrect format (yyyyMMdd), fromDate = " + fromDate,
                    GetType() + ".GetListCashTransOrderHist()",
                    TraceEventType.Warning);
            }

            try
            {
                // convert to date string to DateTime value
                if (!string.IsNullOrEmpty(toDate))
                {
                    var toDateSearch = new DateTime(
                    int.Parse(toDate.Substring(0, 4)),
                    int.Parse(toDate.Substring(4, 2)),
                    int.Parse(toDate.Substring(6, 2)));
                    toDate = toDateSearch.AddDays(1).ToString("dd/MM/yyyy");
                }
            }
            catch
            {
                LogHandler.Log(
                    "GetListCashTransOrderHist: toDate was incorrect format (yyyyMMdd), toDate = " + toDate,
                    GetType() + ".GetListCashTransOrderHist()",
                    TraceEventType.Warning);
            }

            PagingObject<List<CashTransfer>> listCashTransfer = _cashTransferService.GetListCashTransOrderHist(
                                                                sourceAccountID, destAccountID, fromDate, toDate, transType,
                                                                status, note, brokerID, pageIndex, pageSize);
            if(listCashTransfer!=null && listCashTransfer.Data!=null)
            {
                return new ResultObject<PagingObject<List<CashTransfer>>>()
                           {
                               Result = listCashTransfer,
                               ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS.ToString(),
                               RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS
                           };
            }
            else
            {
                return new ResultObject<PagingObject<List<CashTransfer>>>()
                {
                    Result = listCashTransfer,
                    ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                    RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA
                };
            }
        }

        /// <summary>
        /// Cancels the cash transfer.
        /// </summary>
        /// <param name="id">The id.</param>
        /// <param name="note">The note.</param>
        /// <returns></returns>
        public int CancelCashTransfer(long id,string note)
        {
            try
            {
                return _cashTransferService.CancelCashTransfer(id, DateTime.Now, note);
            }
            catch (Exception)
            {

                return (int) ETradeCommon.Enums.CommonEnums.RET_CODE.SYSTEM_ERROR;
            }
        }

        #endregion

        #region Stock Transfer
        /// <summary>
        /// Puts the stock trans order.
        /// </summary>
        /// <param name="TlistSubCustAccount">The tlist sub cust account.</param>
        /// <param name="sourceAccountID">The source account ID.</param>
        /// <param name="destAccountID">The dest account ID.</param>
        /// <param name="secSymbol">The sec symbol.</param>
        /// <param name="requestAmt">The request amt.</param>
        /// <param name="transType">Type of the trans.</param>
        /// <param name="note">The note.</param>
        /// <returns>ret code</returns>
        public int PutStockTransOrder(List<AccountManager.Entities.SubCustAccount> TlistSubCustAccount, string sourceAccountID, string destAccountID,string secSymbol,long requestAmt, int transType, string note)
        {
            try
            {
                if (TlistSubCustAccount == null)
                    return (int) ETradeCommon.Enums.CommonEnums.RET_CODE.FAIL;

                ////only account with margin type can do
                SubCustAccount subCustAccount = TlistSubCustAccount.Where(n => n.SubCustAccountId.Equals(sourceAccountID)).FirstOrDefault();
                if (subCustAccount == null)
                    return (int)ETradeCommon.Enums.CommonEnums.RET_CODE.ERROR_ACCOUNT;

                int bankAccountType = (int)subCustAccount.BankAccountType;
                if (bankAccountType == (int)ETradeCommon.Enums.CommonEnums.BANK_ACCOUNT_TYPE.BANKACC)
                    return (int)ETradeCommon.Enums.CommonEnums.RET_CODE.NOT_ALLOW;

                //check valid account & same in a main account       
                //if (TlistSubCustAccount.Where(n => n.SubCustAccountId.Equals(sourceAccountID)).Count() == 0 ||
                //    TlistSubCustAccount.Where(n => n.SubCustAccountId.Equals(destAccountID)).Count() == 0)
                //    return (int) ETradeCommon.Enums.CommonEnums.RET_CODE.ERROR_NOT_SAME_ACCOUNT;

                //check Request Amount 
                if (requestAmt <= 0)
                    return (int) ETradeCommon.Enums.CommonEnums.RET_CODE.ERROR_REQUEST_AMOUNT;

                ResultObject<StockTransferInfo> resultObjectStockTransferInfo = GetStockTransferInfo(sourceAccountID,
                                                                                                     secSymbol,
                                                                                                     ETradeCommon.Utils.
                                                                                                         GetAccountType(
                                                                                                             sourceAccountID));
                if (resultObjectStockTransferInfo.RetCode == CommonEnums.RET_CODE.SUCCESS &&
                    resultObjectStockTransferInfo.Result != null)
                {
                    //Request Amount > Available Amount -> fail
                    if (resultObjectStockTransferInfo.Result.AvilableAmt < requestAmt)
                        return (int)ETradeCommon.Enums.CommonEnums.RET_CODE.ERROR_REQUEST_AMOUNT;

                    StockTransfer stockTransfer = new StockTransfer();
                    stockTransfer.SecSymbol = secSymbol;
                    stockTransfer.WithdrawableAmt = resultObjectStockTransferInfo.Result.WithdrawableAmt;
                    stockTransfer.TransferedAmt = resultObjectStockTransferInfo.Result.TransferedAmt;
                    stockTransfer.AdvOrderAmt = resultObjectStockTransferInfo.Result.AdvOrderAmt;
                    stockTransfer.AvilableAmt = resultObjectStockTransferInfo.Result.AvilableAmt;
                    stockTransfer.RequestAmt = requestAmt;
                    stockTransfer.RequestTime = DateTime.Now;
                    stockTransfer.SrcAccountId = sourceAccountID;
                    stockTransfer.DestAccountId = destAccountID;
                    stockTransfer.TransType = transType;
                    stockTransfer.Status = (int)ETradeCommon.Enums.CommonEnums.CASH_TRANSFER_STATUS.PENDING;
                    stockTransfer.ApprovedAmt = 0;
                    return _stockTransferService.PutStockTransOrder(stockTransfer);
                }
                else
                    return (int) CommonEnums.RET_CODE.ERROR_NOT_STOCK_AVAILABLE;
            }
            catch (Exception e)
            {
                return (int)ETradeCommon.Enums.CommonEnums.RET_CODE.SYSTEM_ERROR;
            }
        }
        /// <summary>
        /// Gets the list unfinished stock transfer.
        /// </summary>
        /// <param name="subAccountId">The sub account id.</param>
        /// <param name="secSymbol">The sec symbol.</param>
        /// <returns></returns>
        public ResultObject<List<StockTransfer>> GetListUnfinishedStockTransfer(string subAccountId,string secSymbol)
        {
            List<StockTransfer> listUnfinishedStockTransfer =
                _stockTransferService.GetListUnfinishedStockTransfer(subAccountId, secSymbol);

            if(listUnfinishedStockTransfer!=null && listUnfinishedStockTransfer.Count>0)
            {
                return new ResultObject<List<StockTransfer>>()
                           {
                               Result = listUnfinishedStockTransfer,
                               ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS.ToString(),
                               RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS
                           };
            }
            else
            {
                return new ResultObject<List<StockTransfer>>()
                           {
                               Result = null,
                               ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                               RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA
                           };
            }
        }

        /// <summary>
        /// Gets the list stock trans order hist.
        /// </summary>
        /// <param name="sourceAccountID">The source account ID.</param>
        /// <param name="destAccountID">The dest account ID.</param>
        /// <param name="secSymbol">The sec symbol.</param>
        /// <param name="fromDate">From date.</param>
        /// <param name="toDate">To date.</param>
        /// <param name="transType">Type of the trans.</param>
        /// <param name="status">The status.</param>
        /// <param name="note">The note.</param>
        /// <param name="brokerID">The broker ID.</param>
        /// <param name="pageIndex">Index of the page.</param>
        /// <param name="pageSize">Size of the page.</param>
        /// <returns></returns>
        public ResultObject<PagingObject<List<StockTransfer>>> GetListStockTransOrderHist(string sourceAccountID,string destAccountID,string secSymbol,string fromDate,string toDate,int transType,int status,string note,string brokerID,int pageIndex,int pageSize)
        {
            try
            {
                // convert from date string to DateTime value
                if (!string.IsNullOrEmpty(fromDate))
                {
                    var fromDateSearch = new DateTime(
                    int.Parse(fromDate.Substring(0, 4)),
                    int.Parse(fromDate.Substring(4, 2)),
                    int.Parse(fromDate.Substring(6, 2)));
                    fromDate = fromDateSearch.ToString("dd/MM/yyyy");
                }
            }
            catch
            {
                LogHandler.Log(
                    "GetListStockTransOrderHist: fromDate was incorrect format (yyyyMMdd), fromDate = " + fromDate,
                    GetType() + ".GetListStockTransOrderHist()",
                    TraceEventType.Warning);
            }
            try
            {
                // convert to date string to DateTime value
                if (!string.IsNullOrEmpty(toDate))
                {
                    var toDateSearch = new DateTime(
                    int.Parse(toDate.Substring(0, 4)),
                    int.Parse(toDate.Substring(4, 2)),
                    int.Parse(toDate.Substring(6, 2)));
                    toDate = toDateSearch.AddDays(1).ToString("dd/MM/yyyy");
                }
            }
            catch
            {
                LogHandler.Log(
                    "GetListStockTransOrderHist: toDate was incorrect format (yyyyMMdd), toDate = " + toDate,
                    GetType() + ".GetListStockTransOrderHist()",
                    TraceEventType.Warning);
            }
            PagingObject<List<StockTransfer>> listStockTransfer =
                _stockTransferService.GetListStockTransOrderHist(sourceAccountID, destAccountID, secSymbol, fromDate,
                                                                 toDate, transType, status, note, brokerID, pageIndex,
                                                                 pageSize);
            if(listStockTransfer!=null && listStockTransfer.Count>0)
            {
                return new ResultObject<PagingObject<List<StockTransfer>>>()
                           {
                               Result = listStockTransfer,
                               ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS.ToString(),
                               RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS
                           };
            }            
            else
            {
                return new ResultObject<PagingObject<List<StockTransfer>>>()
                           {
                               Result = null,
                               ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                               RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA
                           };
            }
        }

        /// <summary>
        /// Gets the cash transfer info.
        /// </summary>
        /// <param name="subAccountId">The sub account id.</param>
        /// <param name="secSymbol">The sec symbol.</param>
        /// <param name="accountType">Type of the account.</param>
        /// <returns></returns>
        public ResultObject<StockTransferInfo> GetStockTransferInfo(string subAccountId,string secSymbol, int accountType)
        {
            StockAvailable stockAvailable = _stockServices.GetStockAvailable(subAccountId, secSymbol, accountType);
            if(stockAvailable!=null)
            {
                StockTransferInfo stockTransferInfo=new StockTransferInfo();
                stockTransferInfo.subAccountId = subAccountId;
                stockTransferInfo.SecSymbol = secSymbol;
                stockTransferInfo.WithdrawableAmt = Convert.ToInt64(stockAvailable.AvaiVolume);
                stockTransferInfo.TransferedAmt =_stockTransferService.GetTotalUnfinishedStockTransferAmount(subAccountId, secSymbol);
                stockTransferInfo.AdvOrderAmt = Convert.ToInt64(_validateServices.GetTotalConditionOrderStock((char)ETradeCommon.Enums.CommonEnums.TRADE_SIDE.BUY,subAccountId,-1,secSymbol));
                /*stockTransferInfo.AvilableAmt = stockTransferInfo.WithdrawableAmt - stockTransferInfo.TransferedAmt -stockTransferInfo.AdvOrderAmt;*/
                stockTransferInfo.AvilableAmt = stockTransferInfo.WithdrawableAmt - stockTransferInfo.TransferedAmt;

                return new ResultObject<StockTransferInfo>()
                           {
                               Result = stockTransferInfo,
                               ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS.ToString(),
                               RetCode =ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS
                           };
            }
            else
            {
                return new ResultObject<StockTransferInfo>()
                           {
                               Result = null,
                               ErrorMessage=ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                               RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA
                           };
            }
        }

        /// <summary>
        /// Gets the list stock transfer info.
        /// </summary>
        /// <param name="subAccountId">The sub account id.</param>
        /// <param name="accountType">Type of the account.</param>
        /// <returns></returns>
        public ResultObject<PagingObject<List<StockTransferInfo>>> GetListStockTransferInfo(string subAccountId, int accountType,int pageIndex,int pageSize)
        {
            List<string> listPortfolio = _stockServices.GetListPortfolio(subAccountId, accountType);
            if(listPortfolio!=null && listPortfolio.Count>0)
            {
                PagingObject<List<StockTransferInfo>> listStockTransferInfo=new PagingObject<List<StockTransferInfo>>();
                listStockTransferInfo.Data = new List<StockTransferInfo>();
                foreach (var portfolioInfo in listPortfolio)
                {
                    StockAvailable stockAvailable = _stockServices.GetStockAvailable(subAccountId, portfolioInfo.ToString(), accountType);
                    if (stockAvailable != null)
                    {
                        StockTransferInfo stockTransferInfo = new StockTransferInfo();
                        stockTransferInfo.subAccountId = subAccountId;
                        stockTransferInfo.SecSymbol = portfolioInfo.ToString();
                        stockTransferInfo.WithdrawableAmt = Convert.ToInt64(stockAvailable.AvaiVolume);
                        stockTransferInfo.TransferedAmt = _stockTransferService.GetTotalUnfinishedStockTransferAmount(subAccountId, portfolioInfo);
                        stockTransferInfo.AdvOrderAmt = Convert.ToInt64(_validateServices.GetTotalConditionOrderStock((char)ETradeCommon.Enums.CommonEnums.TRADE_SIDE.BUY, subAccountId, -1, portfolioInfo));
                        stockTransferInfo.AvilableAmt = stockTransferInfo.WithdrawableAmt - stockTransferInfo.TransferedAmt - stockTransferInfo.AdvOrderAmt;
                        listStockTransferInfo.Data.Add(stockTransferInfo);
                    }
                }
                listStockTransferInfo.Data =
                    listStockTransferInfo.Data.Skip(((pageIndex - 1)*pageSize)).Take(pageSize).ToList();
                listStockTransferInfo.Count = listPortfolio.Count;
                return new ResultObject<PagingObject<List<StockTransferInfo>>>()
                           {
                               Result = listStockTransferInfo,
                               ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS.ToString(),
                               RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS
                           };
            }
            else
            {
                return new ResultObject<PagingObject<List<StockTransferInfo>>>()
                {
                    Result = null,
                    ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                    RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA
                };
            }           
        }
       
        /// <summary>
        /// Cancels the stock transfer.
        /// </summary>
        /// <param name="id">The id.</param>
        /// <param name="note">The note.</param>
        /// <returns></returns>
        public int CancelStockTransfer(long id,string note)
        {
            try
            {
                return _stockTransferService.CancelStockTransfer(id, DateTime.Now, note);
            }
            catch (Exception)
            {

                return (int) ETradeCommon.Enums.CommonEnums.RET_CODE.SYSTEM_ERROR;
            }
        }

        #endregion

        #region XR Order
        /// <summary>
        /// Gets the list buy right.
        /// </summary>
        /// <param name="id">The id.</param>
        /// <param name="secSymbol">The sec symbol.</param>
        /// <param name="execDate">The exec date.</param>
        /// <param name="beginDateToRegister">The begin date to register.</param>
        /// <param name="endDateToRegister">The end date to register.</param>
        /// <param name="beginDateToTransfer">The begin date to transfer.</param>
        /// <param name="endDateToTransfer">The end date to transfer.</param>
        /// <param name="receivedDate">The received date.</param>
        /// <param name="note">The note.</param>
        /// <param name="brokerID">The broker ID.</param>
        /// <param name="pageIndex">Index of the page.</param>
        /// <param name="pageSize">Size of the page.</param>
        /// <returns>ResulObject PagingObject List BuyRight</returns>
        public string GetListBuyRight(long id, string secSymbol,string market,string subAccountId,string execDate,string beginDateToRegister,string endDateToRegister,string beginDateToTransfer,string endDateToTransfer,string receivedDate,string note,string brokerID,int pageIndex,int pageSize)
        {
            return _accountManagerServices.GetListBuyRightNoSession(id, secSymbol, market, subAccountId, execDate, beginDateToRegister,
                                                                       endDateToRegister, beginDateToTransfer, endDateToTransfer,
                                                                       receivedDate, note, brokerID, pageIndex, pageSize);
        }

        /// <summary>
        /// Puts the XR order.
        /// </summary>
        /// <param name="subAccountID">The sub account ID.</param>
        /// <param name="buyRightID">The buy right ID.</param>
        /// <param name="secSymbol">The sec symbol.</param>
        /// <param name="market">The market.</param>
        /// <param name="price">The price.</param>
        /// <param name="requestVol">The request vol.</param>
        /// <param name="note">The note.</param>
        /// <returns></returns>
        public int PutXROrder(string subAccountID, long buyRightID, string secSymbol, char market, long requestVol, string note)
        {
            try
            {
                ResultObject<PagingObject<List<BuyRight>>> resulObjectPagingObjectListBuyRight = Serializer.Deserialize<ResultObject<PagingObject<List<BuyRight>>>>(GetListBuyRight(buyRightID,secSymbol,market.ToString(), string.Empty,
                                                                                                                                                                     string.Empty, string.Empty, string.Empty,
                                                                                                                                                                     string.Empty, string.Empty, string.Empty,
                                                                                                                                                                     string.Empty, string.Empty, 1, int.MaxValue));
                if (resulObjectPagingObjectListBuyRight != null && resulObjectPagingObjectListBuyRight.RetCode == CommonEnums.RET_CODE.SUCCESS && resulObjectPagingObjectListBuyRight.Result.Count > 0)
                {
                    BuyRight buyRight = resulObjectPagingObjectListBuyRight.Result.Data.FirstOrDefault();
                    if(buyRight!=null)
                    {
                        if(requestVol<=0)
                        {
                            return (int)CommonEnums.RET_CODE.ERROR_REQUEST_VOLUME_BUY_RIGHT; 
                        }
                        if ((requestVol > (buyRight.AllowedVol - buyRight.RegisteredVol)) || (buyRight.AllowedVol - buyRight.RegisteredVol < 0))
                        {
                            return (int)CommonEnums.RET_CODE.ERROR_OVER_REQUEST_CAN_BUY_RIGHT;
                        }
                        XrOrders xrOrders=new XrOrders();
                        xrOrders.SubAccountId=subAccountID;
                        xrOrders.BuyRightId = buyRightID;
                        xrOrders.SecSymbol=secSymbol;
                        xrOrders.Market = market.ToString();
                        xrOrders.Volume = buyRight.AllowedVol;
                        xrOrders.Price = buyRight.Price;
                        xrOrders.RegisteredVol = buyRight.RegisteredVol;
                        xrOrders.AvailableVol = buyRight.AllowedVol - buyRight.RegisteredVol;
                        xrOrders.RequestVol = requestVol;
                        xrOrders.RequestTime = DateTime.Now;
                        xrOrders.ApprovedVol = 0;
                        xrOrders.Status =(int) CommonEnums.XRORDER_STATUS.PENDING;
                        xrOrders.Note = note;
                        return _xrOrdersService.PutXROrder(xrOrders);
                    }
                    else
                    {
                        return (int)CommonEnums.RET_CODE.ERROR_NOT_EXIST_BUY_RIGHT;
                    }
                }
                else
                {
                    return (int)CommonEnums.RET_CODE.ERROR_NOT_EXIST_BUY_RIGHT;
                }
            }
            catch (Exception e)
            {
                return (int)ETradeCommon.Enums.CommonEnums.RET_CODE.SYSTEM_ERROR;
            }
        }

        /// <summary>
        /// Cancels the XR order.
        /// </summary>
        /// <param name="id">The id.</param>
        /// <param name="note">The note.</param>
        /// <returns></returns>
        public int CancelXROrder(long id,string note)
        {
            try
            {
                return _xrOrdersService.CancelXROrder(id, note);               
            }
            catch (Exception e)
            {
                return (int)ETradeCommon.Enums.CommonEnums.RET_CODE.SYSTEM_ERROR;
            }
        }

        /// <summary>
        /// Gets the list XR order hist.
        /// </summary>
        /// <param name="id">The id.</param>
        /// <param name="subAccountId">The sub account id.</param>
        /// <param name="secSymbol">The sec symbol.</param>
        /// <param name="market">The market.</param>
        /// <param name="fromDate">From date.</param>
        /// <param name="toDate">To date.</param>
        /// <param name="status">The status.</param>
        /// <param name="brokerID">The broker ID.</param>
        /// <param name="note">The note.</param>
        /// <param name="pageIndex">Index of the page.</param>
        /// <param name="pageSize">Size of the page.</param>
        /// <returns></returns>
        public ResultObject<PagingObject<List<XrOrders>>> GetListXROrderHist(long id,string subAccountId,string secSymbol,string market,string fromDate,string toDate,int status,string brokerID,string note,int pageIndex,int pageSize)
        {
            try
            {
                PagingObject<List<XrOrders>> resultObject = _xrOrdersService.GetListXROrderHist(id,
                                                                                              subAccountId,
                                                                                              secSymbol,
                                                                                              market,
                                                                                              fromDate,
                                                                                              toDate,
                                                                                              status,
                                                                                              brokerID,
                                                                                              note,
                                                                                              pageIndex,
                                                                                              pageSize);
                if(resultObject!=null && resultObject.Count>0)
                {
                    return new ResultObject<PagingObject<List<XrOrders>>>()
                    {
                        Result = resultObject,
                        ErrorMessage = CommonEnums.RET_CODE.SUCCESS.ToString(),
                        RetCode = CommonEnums.RET_CODE.SUCCESS
                    };
                }
                else
                {
                    return new ResultObject<PagingObject<List<XrOrders>>>()
                    {
                        Result = null,
                        ErrorMessage = CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                        RetCode = CommonEnums.RET_CODE.NO_EXISTED_DATA
                    };
                }
            }
            catch (Exception e)
            {
                return new ResultObject<PagingObject<List<XrOrders>>>()
                           {
                               Result = null,
                               ErrorMessage = CommonEnums.RET_CODE.SYSTEM_ERROR.ToString(),
                               RetCode = CommonEnums.RET_CODE.SYSTEM_ERROR
                           };
            }
        }

        #endregion

        #region Odd Lot Order
        /// <summary>
        /// Gets the odd lot info.
        /// </summary>
        /// <param name="accountNo">The account no.</param>
        /// <param name="accountType">Type of the account.</param>
        /// <returns></returns>
          public ResultObject<List<OddLotOrderInfo>> GetOddLotOrderInfo(string accountNo,int accountType)
        {
            var listPortfolio = _stockServices.GetListPortfolio(accountNo, accountType);
            if(listPortfolio!=null && listPortfolio.Count>0)
            {
                List<OddLotOrderInfo> listOddLotOrderInfo = new List<OddLotOrderInfo>();
                foreach (var symbol in listPortfolio)
                {
                    StockAvailable stockAvailable = _stockServices.GetStockAvailable(accountNo, symbol,
                                                                                         accountType);
                    var resultObjectStockInfo =Serializer.Deserialize<ResultObject<StockInfo>>(_rtServices.GetStockInfo(symbol));

                    if (stockAvailable !=null && resultObjectStockInfo.Result!=null)
                    {
                        OddLotOrderInfo oddLotOrder=new OddLotOrderInfo();
                        oddLotOrder.AccountNo = accountNo;
                        oddLotOrder.Symbol = symbol;                        
                        oddLotOrder.AvaiVolume = stockAvailable.AvaiVolume;
                        oddLotOrder.AvgPrice =stockAvailable.AvgPrice * Convert.ToDecimal(Constants.PERCENT_PRICE_BUY_ODD_LOT);
                        int oddLot = 0;
                        long totalUnfinished = _oddLotOrderService.GetTotalUnfinishedOddLotOrderAmount(accountNo, symbol);
                        bool isShow = true;
                        switch (resultObjectStockInfo.Result.MarketID)
                        {
                            case (int)CommonEnums.MARKET_ID.HOSE:
                                oddLot = Convert.ToInt16(stockAvailable.AvaiVolume % 10);
                                if(oddLot-totalUnfinished<=0)
                                {
                                    isShow = false;
                                    break;
                                }
                                
                                if (oddLot >= 1 && oddLot <= 9)
                                    oddLotOrder.MarketId = resultObjectStockInfo.Result.MarketID;
                                break;

                            case (int)CommonEnums.MARKET_ID.HNX:
                            case (int)CommonEnums.MARKET_ID.UPCoM:
                                oddLot = Convert.ToInt16(stockAvailable.AvaiVolume % 100);
                                if (oddLot - totalUnfinished <= 0)
                                {
                                    isShow = false;
                                    break;
                                }
                                if (oddLot >= 1 && oddLot <= 99)
                                    oddLotOrder.MarketId = resultObjectStockInfo.Result.MarketID;
                                break;
                            
                            default:
                                isShow = false;
                                break;
                        }
                        
                        if(isShow)
                            listOddLotOrderInfo.Add(oddLotOrder);                                                
                    }
                }
                return new ResultObject<List<OddLotOrderInfo>>()
                         {
                             Result = listOddLotOrderInfo,
                             ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS.ToString(),
                             RetCode =ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS
                       };
            }

            return new ResultObject<List<OddLotOrderInfo>>()
                         {
                             Result = null,
                             ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                             RetCode =ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA
                       };
        }

          /// <summary>
          /// Gets the list odd lot order hist.
          /// </summary>
          /// <param name="secSymbol">The sec symbol.</param>
          /// <param name="side">The side.</param>
          /// <param name="fromDate">From date.</param>
          /// <param name="toDate">To date.</param>
          /// <param name="subCustAccountID">The sub cust account ID.</param>
          /// <param name="market">The market.</param>
          /// <param name="status">The status.</param>
          /// <param name="brokerID">The broker ID.</param>
          /// <param name="note">The note.</param>
          /// <returns></returns>
        public ResultObject<PagingObject<List<OddLotOrder>>> GetListOddLotOrderHist(string secSymbol,string side,string fromDate,string toDate,string subCustAccountID,string market,int status,string brokerID,string note,int pageIndex,int pageSize)
        {
            try
            {
                // convert from date string to DateTime value
                if (!string.IsNullOrEmpty(fromDate))
                {
                    var fromDateSearch=new DateTime(
                    int.Parse(fromDate.Substring(0, 4)),
                    int.Parse(fromDate.Substring(4, 2)),
                    int.Parse(fromDate.Substring(6, 2)));
                    fromDate = fromDateSearch.ToString("dd/MM/yyyy");
                }                
            }
            catch
            {               
                LogHandler.Log(
                    "GetListOddLotOrderHist: fromDate was incorrect format (yyyyMMdd), fromDate = " + fromDate,
                    GetType() + ".GetListOddLotOrderHist()",
                    TraceEventType.Warning);
            }

            try
            {
                // convert to date string to DateTime value
                if (!string.IsNullOrEmpty(toDate))
                {
                    var toDateSearch = new DateTime(
                    int.Parse(toDate.Substring(0, 4)),
                    int.Parse(toDate.Substring(4, 2)),
                    int.Parse(toDate.Substring(6, 2)));
                    toDate = toDateSearch.AddDays(1).ToString("dd/MM/yyyy");
                }
            }
            catch
            {
                LogHandler.Log(
                    "GetListOddLotOrderHist: toDate was incorrect format (yyyyMMdd), toDate = " + toDate,
                    GetType() + ".GetListOddLotOrderHist()",
                    TraceEventType.Warning);
            }
              PagingObject<List<OddLotOrder>> pagingOddLotOrder = _oddLotOrderService.GetListOddLotOrderHist(secSymbol,
                                                                                                             side,
                                                                                                             fromDate,
                                                                                                             toDate,
                                                                                                             subCustAccountID,
                                                                                                             market,
                                                                                                             status,
                                                                                                             brokerID,
                                                                                                             note,pageIndex, pageSize );

            if (pagingOddLotOrder != null && pagingOddLotOrder.Data!=null)
            {
                return new ResultObject<PagingObject<List<OddLotOrder>>>()
                           {
                               Result = pagingOddLotOrder,
                               ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS.ToString(),
                               RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.SUCCESS    
                           };
            }
            return new ResultObject<PagingObject<List<OddLotOrder>>>()
            {
                Result = null,
                ErrorMessage = ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA.ToString(),
                RetCode = ETradeCommon.Enums.CommonEnums.RET_CODE.NO_EXISTED_DATA
            };
        }
        /// <summary>
        /// Gets the list odd lot order.
        /// </summary>
        /// <param name="secSymbol">The sec symbol.</param>
        /// <param name="side">The side.</param>
        /// <param name="subCustAccountID">The sub cust account ID.</param>
        /// <param name="market">The market.</param>
        /// <param name="status">The status.</param>
        /// <param name="brokerID">The broker ID.</param>
        /// <param name="note">The note.</param>
        /// <returns></returns>
        public ResultObject<PagingObject<List<OddLotOrder>>> GetListOddLotOrder(string secSymbol,string side,string subCustAccountID,string market,int status,string brokerID,string note,int pageIndex,int pageSize)
        {
            return GetListOddLotOrderHist(secSymbol, side, string.Empty, string.Empty, subCustAccountID, market, status,brokerID, note,pageIndex, pageSize);
        }

        /// <summary>
        /// Cancels the odd lot order.
        /// </summary>
        /// <param name="id">The id.</param>
        /// <param name="note">The note.</param>
        /// <returns></returns>
        public int CancelOddLotOrder(long id,string note)
        {
            try
            {
                return _oddLotOrderService.CancelOddLotOrder(id, DateTime.Now, note);
            }
            catch (Exception e)
            {
                return (int)ETradeCommon.Enums.CommonEnums.RET_CODE.SYSTEM_ERROR;
            }
        }

        /// <summary>
        /// Puts the odd lot order.
        /// </summary>
        /// <param name="secSymbol">The sec symbol.</param>
        /// <param name="side">The side.</param>
        /// <param name="price">The price.</param>
        /// <param name="volume">The volume.</param>
        /// <param name="subCustAccountID">The sub cust account ID.</param>
        /// <param name="market">The market.</param>
        /// <param name="note">The note.</param>
        /// <returns></returns>        
        public int PutOddLotOrder(string secSymbol,string side,decimal price,long volume,string subCustAccountID,string market,string note)
        {
            try
            {
                OddLotOrder oddLotOrder=new OddLotOrder();
                oddLotOrder.SecSymbol=secSymbol;
                oddLotOrder.Side=side;
                oddLotOrder.Price=price;
                oddLotOrder.Volume=volume;
                oddLotOrder.SubCustAccountId=subCustAccountID;
                oddLotOrder.Market=market;
                oddLotOrder.ExecPrice = 0;
                oddLotOrder.ExecVol = 0;
                oddLotOrder.CanceledVol = 0;
                oddLotOrder.Status =(int) ETradeCommon.Enums.CommonEnums.ODD_LOT_ORDER_STATUS.PENDING;
                oddLotOrder.RequestTime = DateTime.Now;
                oddLotOrder.Note = note;
                return _oddLotOrderService.PutOddLotOrder(oddLotOrder);
            }
            catch (Exception e)
            {
                return (int)ETradeCommon.Enums.CommonEnums.RET_CODE.SYSTEM_ERROR;
            }
        }
        #endregion
    }
}
