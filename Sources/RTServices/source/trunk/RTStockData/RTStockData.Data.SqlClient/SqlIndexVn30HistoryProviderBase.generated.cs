
/*
	File Generated by NetTiers templates [www.nettiers.com]
	Important: Do not modify this file. Edit the file SqlIndexVn30HistoryProvider.cs instead.
*/

#region using directives

using System;
using System.Data;
using System.Data.Common;
using System.Text;

using Microsoft.Practices.EnterpriseLibrary.Data;
using Microsoft.Practices.EnterpriseLibrary.Data.Sql;

using System.Collections;
using System.Collections.Specialized;

using System.Diagnostics;
using RTStockData.Entities;
using RTStockData.Data;
using RTStockData.Data.Bases;

#endregion

namespace RTStockData.Data.SqlClient
{
    ///<summary>
    /// This class is the SqlClient Data Access Logic Component implementation for the <see cref="IndexVn30History"/> entity.
    ///</summary>
    public abstract partial class SqlIndexVn30HistoryProviderBase : IndexVn30HistoryProviderBase
    {
        #region Declarations

        string _connectionString;
        bool _useStoredProcedure;
        string _providerInvariantName;

        #endregion "Declarations"

        #region Constructors

        /// <summary>
        /// Creates a new <see cref="SqlIndexVn30HistoryProviderBase"/> instance.
        /// </summary>
        public SqlIndexVn30HistoryProviderBase()
        {
        }

        /// <summary>
        /// Creates a new <see cref="SqlIndexVn30HistoryProviderBase"/> instance.
        /// Uses connection string to connect to datasource.
        /// </summary>
        /// <param name="connectionString">The connection string to the database.</param>
        /// <param name="useStoredProcedure">A boolean value that indicates if we should use stored procedures or embedded queries.</param>
        /// <param name="providerInvariantName">Name of the invariant provider use by the DbProviderFactory.</param>
        public SqlIndexVn30HistoryProviderBase(string connectionString, bool useStoredProcedure, string providerInvariantName)
        {
            this._connectionString = connectionString;
            this._useStoredProcedure = useStoredProcedure;
            this._providerInvariantName = providerInvariantName;
        }

        #endregion "Constructors"

        #region Public properties
        /// <summary>
        /// Gets or sets the connection string.
        /// </summary>
        /// <value>The connection string.</value>
        public string ConnectionString
        {
            get { return this._connectionString; }
            set { this._connectionString = value; }
        }

        /// <summary>
        /// Gets or sets a value indicating whether to use stored procedures.
        /// </summary>
        /// <value><c>true</c> if we choose to use use stored procedures; otherwise, <c>false</c>.</value>
        public bool UseStoredProcedure
        {
            get { return this._useStoredProcedure; }
            set { this._useStoredProcedure = value; }
        }

        /// <summary>
        /// Gets or sets the invariant provider name listed in the DbProviderFactories machine.config section.
        /// </summary>
        /// <value>The name of the provider invariant.</value>
        public string ProviderInvariantName
        {
            get { return this._providerInvariantName; }
            set { this._providerInvariantName = value; }
        }
        #endregion

        #region Get Many To Many Relationship Functions
        #endregion

        #region Delete Functions
        /// <summary>
        /// 	Deletes a row from the DataSource.
        /// </summary>
        /// <param name="_id">. Primary Key.</param>	
        /// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
        /// <remarks>Deletes based on primary key(s).</remarks>
        /// <returns>Returns true if operation suceeded.</returns>
        /// <exception cref="System.Exception">The command could not be executed.</exception>
        /// <exception cref="System.Data.DataException">The <paramref name="transactionManager"/> is not open.</exception>
        /// <exception cref="System.Data.Common.DbException">The command could not be executed.</exception>
        public override bool Delete(TransactionManager transactionManager, System.Int64 _id)
        {
            SqlDatabase database = new SqlDatabase(this._connectionString);
            DbCommand commandWrapper = StoredProcedureProvider.GetCommandWrapper(database, "dbo.IndexVN30_History_Delete", _useStoredProcedure);
            database.AddInParameter(commandWrapper, "@Id", DbType.Int64, _id);

            //Provider Data Requesting Command Event
            OnDataRequesting(new CommandEventArgs(commandWrapper, "Delete"));

            int results = 0;

            if (transactionManager != null)
            {
                results = Utility.ExecuteNonQuery(transactionManager, commandWrapper);
            }
            else
            {
                results = Utility.ExecuteNonQuery(database, commandWrapper);
            }

            //Stop Tracking Now that it has been updated and persisted.
            if (DataRepository.Provider.EnableEntityTracking)
            {
                string entityKey = EntityLocator.ConstructKeyFromPkItems(typeof(IndexVn30History)
                    , _id);
                EntityManager.StopTracking(entityKey);
            }

            //Provider Data Requested Command Event
            OnDataRequested(new CommandEventArgs(commandWrapper, "Delete"));

            commandWrapper = null;

            return Convert.ToBoolean(results);
        }//end Delete
        #endregion

        #region Find Functions

        #region Parsed Find Methods
        /// <summary>
        /// 	Returns rows meeting the whereClause condition from the DataSource.
        /// </summary>
        /// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
        /// <param name="whereClause">Specifies the condition for the rows returned by a query (Name='John Doe', Name='John Doe' AND Id='1', Name='John Doe' OR Id='1').</param>
        /// <param name="start">Row number at which to start reading.</param>
        /// <param name="pageLength">Number of rows to return.</param>
        /// <param name="count">out. The number of rows that match this query.</param>
        /// <remarks>Operators must be capitalized (OR, AND).</remarks>
        /// <returns>Returns a typed collection of RTStockData.Entities.IndexVn30History objects.</returns>
        public override TList<IndexVn30History> Find(TransactionManager transactionManager, string whereClause, int start, int pageLength, out int count)
        {
            count = -1;
            if (whereClause.IndexOf(";") > -1)
                return new TList<IndexVn30History>();

            SqlDatabase database = new SqlDatabase(this._connectionString);
            DbCommand commandWrapper = StoredProcedureProvider.GetCommandWrapper(database, "dbo.IndexVN30_History_Find", _useStoredProcedure);

            bool searchUsingOR = false;
            if (whereClause.IndexOf(" OR ") > 0) // did they want to do "a=b OR c=d OR..."?
                searchUsingOR = true;

            database.AddInParameter(commandWrapper, "@SearchUsingOR", DbType.Boolean, searchUsingOR);

            database.AddInParameter(commandWrapper, "@Id", DbType.Int64, DBNull.Value);
            database.AddInParameter(commandWrapper, "@TradeDate", DbType.DateTime, DBNull.Value);
            database.AddInParameter(commandWrapper, "@Index", DbType.Int64, DBNull.Value);
            database.AddInParameter(commandWrapper, "@TotalShares", DbType.Int64, DBNull.Value);
            database.AddInParameter(commandWrapper, "@TotalValues", DbType.Int64, DBNull.Value);
            database.AddInParameter(commandWrapper, "@Up", DbType.Int64, DBNull.Value);
            database.AddInParameter(commandWrapper, "@Down", DbType.Int64, DBNull.Value);
            database.AddInParameter(commandWrapper, "@NoChange", DbType.Int64, DBNull.Value);
            database.AddInParameter(commandWrapper, "@Time", DbType.Int64, DBNull.Value);
            database.AddInParameter(commandWrapper, "@Change", DbType.Int64, DBNull.Value);
            database.AddInParameter(commandWrapper, "@PerChange", DbType.Double, DBNull.Value);

            // replace all instances of 'AND' and 'OR' because we already set searchUsingOR
            whereClause = whereClause.Replace(" AND ", "|").Replace(" OR ", "|");
            string[] clauses = whereClause.ToLower().Split('|');

            // Here's what's going on below: Find a field, then to get the value we
            // drop the field name from the front, trim spaces, drop the '=' sign,
            // trim more spaces, and drop any outer single quotes.
            // Now handles the case when two fields start off the same way - like "Friendly='Yes' AND Friend='john'"

            char[] equalSign = { '=' };
            char[] singleQuote = { '\'' };
            foreach (string clause in clauses)
            {
                if (clause.Trim().StartsWith("id ") || clause.Trim().StartsWith("id="))
                {
                    database.SetParameterValue(commandWrapper, "@Id",
                        clause.Trim().Remove(0, 2).Trim().TrimStart(equalSign).Trim().Trim(singleQuote));
                    continue;
                }
                if (clause.Trim().StartsWith("tradedate ") || clause.Trim().StartsWith("tradedate="))
                {
                    database.SetParameterValue(commandWrapper, "@TradeDate",
                        clause.Trim().Remove(0, 9).Trim().TrimStart(equalSign).Trim().Trim(singleQuote));
                    continue;
                }
                if (clause.Trim().StartsWith("index ") || clause.Trim().StartsWith("index="))
                {
                    database.SetParameterValue(commandWrapper, "@Index",
                        clause.Trim().Remove(0, 5).Trim().TrimStart(equalSign).Trim().Trim(singleQuote));
                    continue;
                }
                if (clause.Trim().StartsWith("totalshares ") || clause.Trim().StartsWith("totalshares="))
                {
                    database.SetParameterValue(commandWrapper, "@TotalShares",
                        clause.Trim().Remove(0, 11).Trim().TrimStart(equalSign).Trim().Trim(singleQuote));
                    continue;
                }
                if (clause.Trim().StartsWith("totalvalues ") || clause.Trim().StartsWith("totalvalues="))
                {
                    database.SetParameterValue(commandWrapper, "@TotalValues",
                        clause.Trim().Remove(0, 11).Trim().TrimStart(equalSign).Trim().Trim(singleQuote));
                    continue;
                }
                if (clause.Trim().StartsWith("up ") || clause.Trim().StartsWith("up="))
                {
                    database.SetParameterValue(commandWrapper, "@Up",
                        clause.Trim().Remove(0, 2).Trim().TrimStart(equalSign).Trim().Trim(singleQuote));
                    continue;
                }
                if (clause.Trim().StartsWith("down ") || clause.Trim().StartsWith("down="))
                {
                    database.SetParameterValue(commandWrapper, "@Down",
                        clause.Trim().Remove(0, 4).Trim().TrimStart(equalSign).Trim().Trim(singleQuote));
                    continue;
                }
                if (clause.Trim().StartsWith("nochange ") || clause.Trim().StartsWith("nochange="))
                {
                    database.SetParameterValue(commandWrapper, "@NoChange",
                        clause.Trim().Remove(0, 8).Trim().TrimStart(equalSign).Trim().Trim(singleQuote));
                    continue;
                }
                if (clause.Trim().StartsWith("time ") || clause.Trim().StartsWith("time="))
                {
                    database.SetParameterValue(commandWrapper, "@Time",
                        clause.Trim().Remove(0, 4).Trim().TrimStart(equalSign).Trim().Trim(singleQuote));
                    continue;
                }
                if (clause.Trim().StartsWith("change ") || clause.Trim().StartsWith("change="))
                {
                    database.SetParameterValue(commandWrapper, "@Change",
                        clause.Trim().Remove(0, 6).Trim().TrimStart(equalSign).Trim().Trim(singleQuote));
                    continue;
                }
                if (clause.Trim().StartsWith("perchange ") || clause.Trim().StartsWith("perchange="))
                {
                    database.SetParameterValue(commandWrapper, "@PerChange",
                        clause.Trim().Remove(0, 9).Trim().TrimStart(equalSign).Trim().Trim(singleQuote));
                    continue;
                }

                throw new ArgumentException("Unable to use this part of the where clause in this version of Find: " + clause);
            }

            IDataReader reader = null;
            //Create Collection
            TList<IndexVn30History> rows = new TList<IndexVn30History>();


            try
            {
                //Provider Data Requesting Command Event
                OnDataRequesting(new CommandEventArgs(commandWrapper, "Find", rows));

                if (transactionManager != null)
                {
                    reader = Utility.ExecuteReader(transactionManager, commandWrapper);
                }
                else
                {
                    reader = Utility.ExecuteReader(database, commandWrapper);
                }

                Fill(reader, rows, start, pageLength);

                if (reader.NextResult())
                {
                    if (reader.Read())
                    {
                        count = reader.GetInt32(0);
                    }
                }

                //Provider Data Requested Command Event
                OnDataRequested(new CommandEventArgs(commandWrapper, "Find", rows));
            }
            finally
            {
                if (reader != null)
                    reader.Close();

                commandWrapper = null;
            }
            return rows;
        }

        #endregion Parsed Find Methods

        #region Parameterized Find Methods

        /// <summary>
        /// 	Returns rows from the DataSource that meet the parameter conditions.
        /// </summary>
        /// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
        /// <param name="parameters">A collection of <see cref="SqlFilterParameter"/> objects.</param>
        /// <param name="orderBy">Specifies the sort criteria for the rows in the DataSource (Name ASC; BirthDay DESC, Name ASC);</param>
        /// <param name="start">Row number at which to start reading.</param>
        /// <param name="pageLength">Number of rows to return.</param>
        /// <param name="count">out. The number of rows that match this query.</param>
        /// <returns>Returns a typed collection of RTStockData.Entities.IndexVn30History objects.</returns>
        public override TList<IndexVn30History> Find(TransactionManager transactionManager, IFilterParameterCollection parameters, string orderBy, int start, int pageLength, out int count)
        {
            SqlFilterParameterCollection filter = null;

            if (parameters == null)
                filter = new SqlFilterParameterCollection();
            else
                filter = parameters.GetParameters();

            SqlDatabase database = new SqlDatabase(this._connectionString);
            DbCommand commandWrapper = StoredProcedureProvider.GetCommandWrapper(database, "dbo.IndexVN30_History_Find_Dynamic", typeof(IndexVn30HistoryColumn), filter, orderBy, start, pageLength);

            SqlFilterParameter param;

            for (int i = 0; i < filter.Count; i++)
            {
                param = filter[i];
                database.AddInParameter(commandWrapper, param.Name, param.DbType, param.GetValue());
            }

            TList<IndexVn30History> rows = new TList<IndexVn30History>();
            IDataReader reader = null;

            try
            {
                //Provider Data Requesting Command Event
                OnDataRequesting(new CommandEventArgs(commandWrapper, "Find", rows));

                if (transactionManager != null)
                {
                    reader = Utility.ExecuteReader(transactionManager, commandWrapper);
                }
                else
                {
                    reader = Utility.ExecuteReader(database, commandWrapper);
                }

                Fill(reader, rows, 0, int.MaxValue);
                count = rows.Count;

                if (reader.NextResult())
                {
                    if (reader.Read())
                    {
                        count = reader.GetInt32(0);
                    }
                }

                //Provider Data Requested Command Event
                OnDataRequested(new CommandEventArgs(commandWrapper, "Find", rows));
            }
            finally
            {
                if (reader != null)
                    reader.Close();

                commandWrapper = null;
            }

            return rows;
        }

        #endregion Parameterized Find Methods

        #endregion Find Functions

        #region GetAll Methods

        /// <summary>
        /// 	Gets All rows from the DataSource.
        /// </summary>
        /// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
        /// <param name="start">Row number at which to start reading.</param>
        /// <param name="pageLength">Number of rows to return.</param>
        /// <param name="count">out. The number of rows that match this query.</param>
        /// <remarks></remarks>
        /// <returns>Returns a typed collection of RTStockData.Entities.IndexVn30History objects.</returns>
        /// <exception cref="System.Exception">The command could not be executed.</exception>
        /// <exception cref="System.Data.DataException">The <paramref name="transactionManager"/> is not open.</exception>
        /// <exception cref="System.Data.Common.DbException">The command could not be executed.</exception>
        public override TList<IndexVn30History> GetAll(TransactionManager transactionManager, int start, int pageLength, out int count)
        {
            SqlDatabase database = new SqlDatabase(this._connectionString);
            DbCommand commandWrapper = StoredProcedureProvider.GetCommandWrapper(database, "dbo.IndexVN30_History_Get_List", _useStoredProcedure);

            IDataReader reader = null;

            //Create Collection
            TList<IndexVn30History> rows = new TList<IndexVn30History>();

            try
            {
                //Provider Data Requesting Command Event
                OnDataRequesting(new CommandEventArgs(commandWrapper, "GetAll", rows));

                if (transactionManager != null)
                {
                    reader = Utility.ExecuteReader(transactionManager, commandWrapper);
                }
                else
                {
                    reader = Utility.ExecuteReader(database, commandWrapper);
                }

                Fill(reader, rows, start, pageLength);
                count = -1;
                if (reader.NextResult())
                {
                    if (reader.Read())
                    {
                        count = reader.GetInt32(0);
                    }
                }

                //Provider Data Requested Command Event
                OnDataRequested(new CommandEventArgs(commandWrapper, "GetAll", rows));
            }
            finally
            {
                if (reader != null)
                    reader.Close();

                commandWrapper = null;
            }
            return rows;
        }//end getall

        #endregion

        #region GetPaged Methods

        /// <summary>
        /// Gets a page of rows from the DataSource.
        /// </summary>
        /// <param name="start">Row number at which to start reading.</param>
        /// <param name="pageLength">Number of rows to return.</param>
        /// <param name="count">Number of rows in the DataSource.</param>
        /// <param name="whereClause">Specifies the condition for the rows returned by a query (Name='John Doe', Name='John Doe' AND Id='1', Name='John Doe' OR Id='1').</param>
        /// <param name="orderBy">Specifies the sort criteria for the rows in the DataSource (Name ASC; BirthDay DESC, Name ASC);</param>
        /// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
        /// <remarks></remarks>
        /// <returns>Returns a typed collection of RTStockData.Entities.IndexVn30History objects.</returns>
        public override TList<IndexVn30History> GetPaged(TransactionManager transactionManager, string whereClause, string orderBy, int start, int pageLength, out int count)
        {
            SqlDatabase database = new SqlDatabase(this._connectionString);
            DbCommand commandWrapper = StoredProcedureProvider.GetCommandWrapper(database, "dbo.IndexVN30_History_GetPaged", _useStoredProcedure);


            if (commandWrapper.CommandType == CommandType.Text
                && commandWrapper.CommandText != null)
            {
                commandWrapper.CommandText = commandWrapper.CommandText.Replace(SqlUtil.PAGE_INDEX, string.Concat(SqlUtil.PAGE_INDEX, Guid.NewGuid().ToString("N").Substring(0, 8)));
            }

            database.AddInParameter(commandWrapper, "@WhereClause", DbType.String, whereClause);
            database.AddInParameter(commandWrapper, "@OrderBy", DbType.String, orderBy);
            database.AddInParameter(commandWrapper, "@PageIndex", DbType.Int32, start);
            database.AddInParameter(commandWrapper, "@PageSize", DbType.Int32, pageLength);

            IDataReader reader = null;
            //Create Collection
            TList<IndexVn30History> rows = new TList<IndexVn30History>();

            try
            {
                //Provider Data Requesting Command Event
                OnDataRequesting(new CommandEventArgs(commandWrapper, "GetPaged", rows));

                if (transactionManager != null)
                {
                    reader = Utility.ExecuteReader(transactionManager, commandWrapper);
                }
                else
                {
                    reader = Utility.ExecuteReader(database, commandWrapper);
                }

                Fill(reader, rows, 0, int.MaxValue);
                count = rows.Count;

                if (reader.NextResult())
                {
                    if (reader.Read())
                    {
                        count = reader.GetInt32(0);
                    }
                }

                //Provider Data Requested Command Event
                OnDataRequested(new CommandEventArgs(commandWrapper, "GetPaged", rows));

            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                if (reader != null)
                    reader.Close();

                commandWrapper = null;
            }

            return rows;
        }

        #endregion

        #region Get By Foreign Key Functions
        #endregion

        #region Get By Index Functions

        #region GetById

        /// <summary>
        /// 	Gets rows from the datasource based on the PK_IndexVN30_History index.
        /// </summary>
        /// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
        /// <param name="_id"></param>
        /// <param name="start">Row number at which to start reading.</param>
        /// <param name="pageLength">Number of rows to return.</param>
        /// <param name="count">out parameter to get total records for query.</param>
        /// <returns>Returns an instance of the <see cref="RTStockData.Entities.IndexVn30History"/> class.</returns>
        /// <remarks></remarks>
        /// <exception cref="System.Exception">The command could not be executed.</exception>
        /// <exception cref="System.Data.DataException">The <paramref name="transactionManager"/> is not open.</exception>
        /// <exception cref="System.Data.Common.DbException">The command could not be executed.</exception>
        public override RTStockData.Entities.IndexVn30History GetById(TransactionManager transactionManager, System.Int64 _id, int start, int pageLength, out int count)
        {
            SqlDatabase database = new SqlDatabase(this._connectionString);
            DbCommand commandWrapper = StoredProcedureProvider.GetCommandWrapper(database, "dbo.IndexVN30_History_GetById", _useStoredProcedure);

            database.AddInParameter(commandWrapper, "@Id", DbType.Int64, _id);

            IDataReader reader = null;
            TList<IndexVn30History> tmp = new TList<IndexVn30History>();
            try
            {
                //Provider Data Requesting Command Event
                OnDataRequesting(new CommandEventArgs(commandWrapper, "GetById", tmp));

                if (transactionManager != null)
                {
                    reader = Utility.ExecuteReader(transactionManager, commandWrapper);
                }
                else
                {
                    reader = Utility.ExecuteReader(database, commandWrapper);
                }

                //Create collection and fill
                Fill(reader, tmp, start, pageLength);
                count = -1;
                if (reader.NextResult())
                {
                    if (reader.Read())
                    {
                        count = reader.GetInt32(0);
                    }
                }

                //Provider Data Requested Command Event
                OnDataRequested(new CommandEventArgs(commandWrapper, "GetById", tmp));
            }
            finally
            {
                if (reader != null)
                    reader.Close();

                commandWrapper = null;
            }

            if (tmp.Count == 1)
            {
                return tmp[0];
            }
            else if (tmp.Count == 0)
            {
                return null;
            }
            else
            {
                throw new DataException("Cannot find the unique instance of the class.");
            }

            //return rows;
        }

        #endregion

        #endregion Get By Index Functions

        #region Insert Methods
        /// <summary>
        /// Lets you efficiently bulk insert many entities to the database.
        /// </summary>
        /// <param name="transactionManager">The transaction manager.</param>
        /// <param name="entities">The entities.</param>
        /// <remarks>
        ///		After inserting into the datasource, the RTStockData.Entities.IndexVn30History object will be updated
        /// 	to refelect any changes made by the datasource. (ie: identity or computed columns)
        /// </remarks>	
        public override void BulkInsert(TransactionManager transactionManager, TList<RTStockData.Entities.IndexVn30History> entities)
        {
            //System.Data.SqlClient.SqlBulkCopy bulkCopy = new System.Data.SqlClient.SqlBulkCopy(this._connectionString, System.Data.SqlClient.SqlBulkCopyOptions.CheckConstraints); //, null);

            System.Data.SqlClient.SqlBulkCopy bulkCopy = null;

            if (transactionManager != null && transactionManager.IsOpen)
            {
                System.Data.SqlClient.SqlConnection cnx = transactionManager.TransactionObject.Connection as System.Data.SqlClient.SqlConnection;
                System.Data.SqlClient.SqlTransaction transaction = transactionManager.TransactionObject as System.Data.SqlClient.SqlTransaction;
                bulkCopy = new System.Data.SqlClient.SqlBulkCopy(cnx, System.Data.SqlClient.SqlBulkCopyOptions.CheckConstraints, transaction); //, null);
            }
            else
            {
                bulkCopy = new System.Data.SqlClient.SqlBulkCopy(this._connectionString, System.Data.SqlClient.SqlBulkCopyOptions.CheckConstraints); //, null);
            }

            bulkCopy.BulkCopyTimeout = 360;
            bulkCopy.DestinationTableName = "IndexVN30_History";

            DataTable dataTable = new DataTable();
            DataColumn col0 = dataTable.Columns.Add("ID", typeof(System.Int64));
            col0.AllowDBNull = false;
            DataColumn col1 = dataTable.Columns.Add("TradeDate", typeof(System.DateTime));
            col1.AllowDBNull = true;
            DataColumn col2 = dataTable.Columns.Add("Index", typeof(System.Int64));
            col2.AllowDBNull = true;
            DataColumn col3 = dataTable.Columns.Add("TotalShares", typeof(System.Int64));
            col3.AllowDBNull = true;
            DataColumn col4 = dataTable.Columns.Add("TotalValues", typeof(System.Int64));
            col4.AllowDBNull = true;
            DataColumn col5 = dataTable.Columns.Add("Up", typeof(System.Int64));
            col5.AllowDBNull = true;
            DataColumn col6 = dataTable.Columns.Add("Down", typeof(System.Int64));
            col6.AllowDBNull = true;
            DataColumn col7 = dataTable.Columns.Add("NoChange", typeof(System.Int64));
            col7.AllowDBNull = true;
            DataColumn col8 = dataTable.Columns.Add("Time", typeof(System.Int64));
            col8.AllowDBNull = true;
            DataColumn col9 = dataTable.Columns.Add("Change", typeof(System.Int64));
            col9.AllowDBNull = true;
            DataColumn col10 = dataTable.Columns.Add("PerChange", typeof(System.Double));
            col10.AllowDBNull = true;

            bulkCopy.ColumnMappings.Add("ID", "ID");
            bulkCopy.ColumnMappings.Add("TradeDate", "TradeDate");
            bulkCopy.ColumnMappings.Add("Index", "Index");
            bulkCopy.ColumnMappings.Add("TotalShares", "TotalShares");
            bulkCopy.ColumnMappings.Add("TotalValues", "TotalValues");
            bulkCopy.ColumnMappings.Add("Up", "Up");
            bulkCopy.ColumnMappings.Add("Down", "Down");
            bulkCopy.ColumnMappings.Add("NoChange", "NoChange");
            bulkCopy.ColumnMappings.Add("Time", "Time");
            bulkCopy.ColumnMappings.Add("Change", "Change");
            bulkCopy.ColumnMappings.Add("PerChange", "PerChange");

            foreach (RTStockData.Entities.IndexVn30History entity in entities)
            {
                if (entity.EntityState != EntityState.Added)
                    continue;

                DataRow row = dataTable.NewRow();

                row["ID"] = entity.Id;


                row["TradeDate"] = entity.TradeDate.HasValue ? (object)entity.TradeDate : System.DBNull.Value;


                row["Index"] = entity.Index.HasValue ? (object)entity.Index : System.DBNull.Value;


                row["TotalShares"] = entity.TotalShares.HasValue ? (object)entity.TotalShares : System.DBNull.Value;


                row["TotalValues"] = entity.TotalValues.HasValue ? (object)entity.TotalValues : System.DBNull.Value;


                row["Up"] = entity.Up.HasValue ? (object)entity.Up : System.DBNull.Value;


                row["Down"] = entity.Down.HasValue ? (object)entity.Down : System.DBNull.Value;


                row["NoChange"] = entity.NoChange.HasValue ? (object)entity.NoChange : System.DBNull.Value;


                row["Time"] = entity.Time.HasValue ? (object)entity.Time : System.DBNull.Value;


                row["Change"] = entity.Change.HasValue ? (object)entity.Change : System.DBNull.Value;


                row["PerChange"] = entity.PerChange.HasValue ? (object)entity.PerChange : System.DBNull.Value;


                dataTable.Rows.Add(row);
            }

            // send the data to the server		
            bulkCopy.WriteToServer(dataTable);

            // update back the state
            foreach (RTStockData.Entities.IndexVn30History entity in entities)
            {
                if (entity.EntityState != EntityState.Added)
                    continue;

                entity.AcceptChanges();
            }
        }

        /// <summary>
        /// 	Inserts a RTStockData.Entities.IndexVn30History object into the datasource using a transaction.
        /// </summary>
        /// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
        /// <param name="entity">RTStockData.Entities.IndexVn30History object to insert.</param>
        /// <remarks>
        ///		After inserting into the datasource, the RTStockData.Entities.IndexVn30History object will be updated
        /// 	to refelect any changes made by the datasource. (ie: identity or computed columns)
        /// </remarks>	
        /// <returns>Returns true if operation is successful.</returns>
        /// <exception cref="System.Exception">The command could not be executed.</exception>
        /// <exception cref="System.Data.DataException">The <paramref name="transactionManager"/> is not open.</exception>
        /// <exception cref="System.Data.Common.DbException">The command could not be executed.</exception>
        public override bool Insert(TransactionManager transactionManager, RTStockData.Entities.IndexVn30History entity)
        {
            SqlDatabase database = new SqlDatabase(this._connectionString);
            DbCommand commandWrapper = StoredProcedureProvider.GetCommandWrapper(database, "dbo.IndexVN30_History_Insert", _useStoredProcedure);

            database.AddOutParameter(commandWrapper, "@Id", DbType.Int64, 8);
            database.AddInParameter(commandWrapper, "@TradeDate", DbType.DateTime, (entity.TradeDate.HasValue ? (object)entity.TradeDate : System.DBNull.Value));
            database.AddInParameter(commandWrapper, "@Index", DbType.Int64, (entity.Index.HasValue ? (object)entity.Index : System.DBNull.Value));
            database.AddInParameter(commandWrapper, "@TotalShares", DbType.Int64, (entity.TotalShares.HasValue ? (object)entity.TotalShares : System.DBNull.Value));
            database.AddInParameter(commandWrapper, "@TotalValues", DbType.Int64, (entity.TotalValues.HasValue ? (object)entity.TotalValues : System.DBNull.Value));
            database.AddInParameter(commandWrapper, "@Up", DbType.Int64, (entity.Up.HasValue ? (object)entity.Up : System.DBNull.Value));
            database.AddInParameter(commandWrapper, "@Down", DbType.Int64, (entity.Down.HasValue ? (object)entity.Down : System.DBNull.Value));
            database.AddInParameter(commandWrapper, "@NoChange", DbType.Int64, (entity.NoChange.HasValue ? (object)entity.NoChange : System.DBNull.Value));
            database.AddInParameter(commandWrapper, "@Time", DbType.Int64, (entity.Time.HasValue ? (object)entity.Time : System.DBNull.Value));
            database.AddInParameter(commandWrapper, "@Change", DbType.Int64, (entity.Change.HasValue ? (object)entity.Change : System.DBNull.Value));
            database.AddInParameter(commandWrapper, "@PerChange", DbType.Double, (entity.PerChange.HasValue ? (object)entity.PerChange : System.DBNull.Value));

            int results = 0;

            //Provider Data Requesting Command Event
            OnDataRequesting(new CommandEventArgs(commandWrapper, "Insert", entity));

            if (transactionManager != null)
            {
                results = Utility.ExecuteNonQuery(transactionManager, commandWrapper);
            }
            else
            {
                results = Utility.ExecuteNonQuery(database, commandWrapper);
            }

            object _id = database.GetParameterValue(commandWrapper, "@Id");
            entity.Id = (System.Int64)_id;


            entity.AcceptChanges();

            //Provider Data Requested Command Event
            OnDataRequested(new CommandEventArgs(commandWrapper, "Insert", entity));

            return Convert.ToBoolean(results);
        }
        #endregion

        #region Update Methods

        /// <summary>
        /// 	Update an existing row in the datasource.
        /// </summary>
        /// <param name="transactionManager"><see cref="TransactionManager"/> object</param>
        /// <param name="entity">RTStockData.Entities.IndexVn30History object to update.</param>
        /// <remarks>
        ///		After updating the datasource, the RTStockData.Entities.IndexVn30History object will be updated
        /// 	to refelect any changes made by the datasource. (ie: identity or computed columns)
        /// </remarks>
        /// <returns>Returns true if operation is successful.</returns>
        /// <exception cref="System.Exception">The command could not be executed.</exception>
        /// <exception cref="System.Data.DataException">The <paramref name="transactionManager"/> is not open.</exception>
        /// <exception cref="System.Data.Common.DbException">The command could not be executed.</exception>
        public override bool Update(TransactionManager transactionManager, RTStockData.Entities.IndexVn30History entity)
        {
            SqlDatabase database = new SqlDatabase(this._connectionString);
            DbCommand commandWrapper = StoredProcedureProvider.GetCommandWrapper(database, "dbo.IndexVN30_History_Update", _useStoredProcedure);

            database.AddInParameter(commandWrapper, "@Id", DbType.Int64, entity.Id);
            database.AddInParameter(commandWrapper, "@TradeDate", DbType.DateTime, (entity.TradeDate.HasValue ? (object)entity.TradeDate : System.DBNull.Value));
            database.AddInParameter(commandWrapper, "@Index", DbType.Int64, (entity.Index.HasValue ? (object)entity.Index : System.DBNull.Value));
            database.AddInParameter(commandWrapper, "@TotalShares", DbType.Int64, (entity.TotalShares.HasValue ? (object)entity.TotalShares : System.DBNull.Value));
            database.AddInParameter(commandWrapper, "@TotalValues", DbType.Int64, (entity.TotalValues.HasValue ? (object)entity.TotalValues : System.DBNull.Value));
            database.AddInParameter(commandWrapper, "@Up", DbType.Int64, (entity.Up.HasValue ? (object)entity.Up : System.DBNull.Value));
            database.AddInParameter(commandWrapper, "@Down", DbType.Int64, (entity.Down.HasValue ? (object)entity.Down : System.DBNull.Value));
            database.AddInParameter(commandWrapper, "@NoChange", DbType.Int64, (entity.NoChange.HasValue ? (object)entity.NoChange : System.DBNull.Value));
            database.AddInParameter(commandWrapper, "@Time", DbType.Int64, (entity.Time.HasValue ? (object)entity.Time : System.DBNull.Value));
            database.AddInParameter(commandWrapper, "@Change", DbType.Int64, (entity.Change.HasValue ? (object)entity.Change : System.DBNull.Value));
            database.AddInParameter(commandWrapper, "@PerChange", DbType.Double, (entity.PerChange.HasValue ? (object)entity.PerChange : System.DBNull.Value));

            int results = 0;

            //Provider Data Requesting Command Event
            OnDataRequesting(new CommandEventArgs(commandWrapper, "Update", entity));

            if (transactionManager != null)
            {
                results = Utility.ExecuteNonQuery(transactionManager, commandWrapper);
            }
            else
            {
                results = Utility.ExecuteNonQuery(database, commandWrapper);
            }

            //Stop Tracking Now that it has been updated and persisted.
            if (DataRepository.Provider.EnableEntityTracking)
                EntityManager.StopTracking(entity.EntityTrackingKey);


            entity.AcceptChanges();

            //Provider Data Requested Command Event
            OnDataRequested(new CommandEventArgs(commandWrapper, "Update", entity));

            return Convert.ToBoolean(results);
        }

        #endregion

        #region Custom Methods

        #endregion
    }//end class
} // end namespace
